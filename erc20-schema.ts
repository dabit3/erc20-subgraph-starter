// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
    TypedMap,
    Entity,
    Value,
    ValueKind,
    store,
    Bytes,
    BigInt,
    BigDecimal
  } from "@graphprotocol/graph-ts";
  
  export class Account extends Entity {
    constructor(id: Bytes) {
      super();
      this.set("id", Value.fromBytes(id));
    }
  
    save(): void {
      let id = this.get("id");
      assert(id != null, "Cannot save Account entity without an ID");
      if (id) {
        assert(
          id.kind == ValueKind.BYTES,
          `Entities of type Account must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
        );
        store.set("Account", id.toBytes().toHexString(), this);
      }
    }
  
    static load(id: Bytes): Account | null {
      return changetype<Account | null>(store.get("Account", id.toHexString()));
    }
  
    get id(): Bytes {
      let value = this.get("id");
      return value!.toBytes();
    }
  
    set id(value: Bytes) {
      this.set("id", Value.fromBytes(value));
    }
  
    get asAccessControl(): Bytes | null {
      let value = this.get("asAccessControl");
      if (!value || value.kind == ValueKind.NULL) {
        return null;
      } else {
        return value.toBytes();
      }
    }
  
    set asAccessControl(value: Bytes | null) {
      if (!value) {
        this.unset("asAccessControl");
      } else {
        this.set("asAccessControl", Value.fromBytes(<Bytes>value));
      }
    }
  
    get membership(): Array<string> {
      let value = this.get("membership");
      return value!.toStringArray();
    }
  
    set membership(value: Array<string>) {
      this.set("membership", Value.fromStringArray(value));
    }
  
    get roleGranted(): Array<string> {
      let value = this.get("roleGranted");
      return value!.toStringArray();
    }
  
    set roleGranted(value: Array<string>) {
      this.set("roleGranted", Value.fromStringArray(value));
    }
  
    get roleGrantedSender(): Array<string> {
      let value = this.get("roleGrantedSender");
      return value!.toStringArray();
    }
  
    set roleGrantedSender(value: Array<string>) {
      this.set("roleGrantedSender", Value.fromStringArray(value));
    }
  
    get roleRevoked(): Array<string> {
      let value = this.get("roleRevoked");
      return value!.toStringArray();
    }
  
    set roleRevoked(value: Array<string>) {
      this.set("roleRevoked", Value.fromStringArray(value));
    }
  
    get roleRevokedSender(): Array<string> {
      let value = this.get("roleRevokedSender");
      return value!.toStringArray();
    }
  
    set roleRevokedSender(value: Array<string>) {
      this.set("roleRevokedSender", Value.fromStringArray(value));
    }
  
    get asERC1155(): Bytes | null {
      let value = this.get("asERC1155");
      if (!value || value.kind == ValueKind.NULL) {
        return null;
      } else {
        return value.toBytes();
      }
    }
  
    set asERC1155(value: Bytes | null) {
      if (!value) {
        this.unset("asERC1155");
      } else {
        this.set("asERC1155", Value.fromBytes(<Bytes>value));
      }
    }
  
    get ERC1155balances(): Array<string> {
      let value = this.get("ERC1155balances");
      return value!.toStringArray();
    }
  
    set ERC1155balances(value: Array<string>) {
      this.set("ERC1155balances", Value.fromStringArray(value));
    }
  
    get ERC1155operatorOwner(): Array<string> {
      let value = this.get("ERC1155operatorOwner");
      return value!.toStringArray();
    }
  
    set ERC1155operatorOwner(value: Array<string>) {
      this.set("ERC1155operatorOwner", Value.fromStringArray(value));
    }
  
    get ERC1155operatorOperator(): Array<string> {
      let value = this.get("ERC1155operatorOperator");
      return value!.toStringArray();
    }
  
    set ERC1155operatorOperator(value: Array<string>) {
      this.set("ERC1155operatorOperator", Value.fromStringArray(value));
    }
  
    get ERC1155transferFromEvent(): Array<string> {
      let value = this.get("ERC1155transferFromEvent");
      return value!.toStringArray();
    }
  
    set ERC1155transferFromEvent(value: Array<string>) {
      this.set("ERC1155transferFromEvent", Value.fromStringArray(value));
    }
  
    get ERC1155transferToEvent(): Array<string> {
      let value = this.get("ERC1155transferToEvent");
      return value!.toStringArray();
    }
  
    set ERC1155transferToEvent(value: Array<string>) {
      this.set("ERC1155transferToEvent", Value.fromStringArray(value));
    }
  
    get ERC1155transferOperatorEvent(): Array<string> {
      let value = this.get("ERC1155transferOperatorEvent");
      return value!.toStringArray();
    }
  
    set ERC1155transferOperatorEvent(value: Array<string>) {
      this.set("ERC1155transferOperatorEvent", Value.fromStringArray(value));
    }
  
    get erc1967Implementation(): Bytes | null {
      let value = this.get("erc1967Implementation");
      if (!value || value.kind == ValueKind.NULL) {
        return null;
      } else {
        return value.toBytes();
      }
    }
  
    set erc1967Implementation(value: Bytes | null) {
      if (!value) {
        this.unset("erc1967Implementation");
      } else {
        this.set("erc1967Implementation", Value.fromBytes(<Bytes>value));
      }
    }
  
    get erc1967Beacon(): Bytes | null {
      let value = this.get("erc1967Beacon");
      if (!value || value.kind == ValueKind.NULL) {
        return null;
      } else {
        return value.toBytes();
      }
    }
  
    set erc1967Beacon(value: Bytes | null) {
      if (!value) {
        this.unset("erc1967Beacon");
      } else {
        this.set("erc1967Beacon", Value.fromBytes(<Bytes>value));
      }
    }
  
    get erc1967Admin(): Bytes | null {
      let value = this.get("erc1967Admin");
      if (!value || value.kind == ValueKind.NULL) {
        return null;
      } else {
        return value.toBytes();
      }
    }
  
    set erc1967Admin(value: Bytes | null) {
      if (!value) {
        this.unset("erc1967Admin");
      } else {
        this.set("erc1967Admin", Value.fromBytes(<Bytes>value));
      }
    }
  
    get erc1967ImplementationOf(): Array<Bytes> {
      let value = this.get("erc1967ImplementationOf");
      return value!.toBytesArray();
    }
  
    set erc1967ImplementationOf(value: Array<Bytes>) {
      this.set("erc1967ImplementationOf", Value.fromBytesArray(value));
    }
  
    get erc1967BeaconOf(): Array<Bytes> {
      let value = this.get("erc1967BeaconOf");
      return value!.toBytesArray();
    }
  
    set erc1967BeaconOf(value: Array<Bytes>) {
      this.set("erc1967BeaconOf", Value.fromBytesArray(value));
    }
  
    get erc1967AdminOf(): Array<Bytes> {
      let value = this.get("erc1967AdminOf");
      return value!.toBytesArray();
    }
  
    set erc1967AdminOf(value: Array<Bytes>) {
      this.set("erc1967AdminOf", Value.fromBytesArray(value));
    }
  
    get ERC1967AdminChanged(): Array<string> {
      let value = this.get("ERC1967AdminChanged");
      return value!.toStringArray();
    }
  
    set ERC1967AdminChanged(value: Array<string>) {
      this.set("ERC1967AdminChanged", Value.fromStringArray(value));
    }
  
    get ERC1967AdminOfChanged(): Array<string> {
      let value = this.get("ERC1967AdminOfChanged");
      return value!.toStringArray();
    }
  
    set ERC1967AdminOfChanged(value: Array<string>) {
      this.set("ERC1967AdminOfChanged", Value.fromStringArray(value));
    }
  
    get ERC1967BeaconUpgraded(): Array<string> {
      let value = this.get("ERC1967BeaconUpgraded");
      return value!.toStringArray();
    }
  
    set ERC1967BeaconUpgraded(value: Array<string>) {
      this.set("ERC1967BeaconUpgraded", Value.fromStringArray(value));
    }
  
    get ERC1967BeaconOfUpgraded(): Array<string> {
      let value = this.get("ERC1967BeaconOfUpgraded");
      return value!.toStringArray();
    }
  
    set ERC1967BeaconOfUpgraded(value: Array<string>) {
      this.set("ERC1967BeaconOfUpgraded", Value.fromStringArray(value));
    }
  
    get ERC1967ImplementationUpgraded(): Array<string> {
      let value = this.get("ERC1967ImplementationUpgraded");
      return value!.toStringArray();
    }
  
    set ERC1967ImplementationUpgraded(value: Array<string>) {
      this.set("ERC1967ImplementationUpgraded", Value.fromStringArray(value));
    }
  
    get ERC1967ImplementationOfUpgraded(): Array<string> {
      let value = this.get("ERC1967ImplementationOfUpgraded");
      return value!.toStringArray();
    }
  
    set ERC1967ImplementationOfUpgraded(value: Array<string>) {
      this.set("ERC1967ImplementationOfUpgraded", Value.fromStringArray(value));
    }
  
    get asERC20(): Bytes | null {
      let value = this.get("asERC20");
      if (!value || value.kind == ValueKind.NULL) {
        return null;
      } else {
        return value.toBytes();
      }
    }
  
    set asERC20(value: Bytes | null) {
      if (!value) {
        this.unset("asERC20");
      } else {
        this.set("asERC20", Value.fromBytes(<Bytes>value));
      }
    }
  
    get ERC20balances(): Array<string> {
      let value = this.get("ERC20balances");
      return value!.toStringArray();
    }
  
    set ERC20balances(value: Array<string>) {
      this.set("ERC20balances", Value.fromStringArray(value));
    }
  
    get ERC20approvalsOwner(): Array<string> {
      let value = this.get("ERC20approvalsOwner");
      return value!.toStringArray();
    }
  
    set ERC20approvalsOwner(value: Array<string>) {
      this.set("ERC20approvalsOwner", Value.fromStringArray(value));
    }
  
    get ERC20approvalsSpender(): Array<string> {
      let value = this.get("ERC20approvalsSpender");
      return value!.toStringArray();
    }
  
    set ERC20approvalsSpender(value: Array<string>) {
      this.set("ERC20approvalsSpender", Value.fromStringArray(value));
    }
  
    get ERC20transferFromEvent(): Array<string> {
      let value = this.get("ERC20transferFromEvent");
      return value!.toStringArray();
    }
  
    set ERC20transferFromEvent(value: Array<string>) {
      this.set("ERC20transferFromEvent", Value.fromStringArray(value));
    }
  
    get ERC20transferToEvent(): Array<string> {
      let value = this.get("ERC20transferToEvent");
      return value!.toStringArray();
    }
  
    set ERC20transferToEvent(value: Array<string>) {
      this.set("ERC20transferToEvent", Value.fromStringArray(value));
    }
  
    get asERC721(): Bytes | null {
      let value = this.get("asERC721");
      if (!value || value.kind == ValueKind.NULL) {
        return null;
      } else {
        return value.toBytes();
      }
    }
  
    set asERC721(value: Bytes | null) {
      if (!value) {
        this.unset("asERC721");
      } else {
        this.set("asERC721", Value.fromBytes(<Bytes>value));
      }
    }
  
    get ERC721tokens(): Array<string> {
      let value = this.get("ERC721tokens");
      return value!.toStringArray();
    }
  
    set ERC721tokens(value: Array<string>) {
      this.set("ERC721tokens", Value.fromStringArray(value));
    }
  
    get ERC721operatorOwner(): Array<string> {
      let value = this.get("ERC721operatorOwner");
      return value!.toStringArray();
    }
  
    set ERC721operatorOwner(value: Array<string>) {
      this.set("ERC721operatorOwner", Value.fromStringArray(value));
    }
  
    get ERC721operatorOperator(): Array<string> {
      let value = this.get("ERC721operatorOperator");
      return value!.toStringArray();
    }
  
    set ERC721operatorOperator(value: Array<string>) {
      this.set("ERC721operatorOperator", Value.fromStringArray(value));
    }
  
    get ERC721transferFromEvent(): Array<string> {
      let value = this.get("ERC721transferFromEvent");
      return value!.toStringArray();
    }
  
    set ERC721transferFromEvent(value: Array<string>) {
      this.set("ERC721transferFromEvent", Value.fromStringArray(value));
    }
  
    get ERC721transferToEvent(): Array<string> {
      let value = this.get("ERC721transferToEvent");
      return value!.toStringArray();
    }
  
    set ERC721transferToEvent(value: Array<string>) {
      this.set("ERC721transferToEvent", Value.fromStringArray(value));
    }
  
    get asGovernor(): Bytes | null {
      let value = this.get("asGovernor");
      if (!value || value.kind == ValueKind.NULL) {
        return null;
      } else {
        return value.toBytes();
      }
    }
  
    set asGovernor(value: Bytes | null) {
      if (!value) {
        this.unset("asGovernor");
      } else {
        this.set("asGovernor", Value.fromBytes(<Bytes>value));
      }
    }
  
    get proposed(): Array<string> {
      let value = this.get("proposed");
      return value!.toStringArray();
    }
  
    set proposed(value: Array<string>) {
      this.set("proposed", Value.fromStringArray(value));
    }
  
    get voted(): Array<string> {
      let value = this.get("voted");
      return value!.toStringArray();
    }
  
    set voted(value: Array<string>) {
      this.set("voted", Value.fromStringArray(value));
    }
  
    get proposedCalls(): Array<string> {
      let value = this.get("proposedCalls");
      return value!.toStringArray();
    }
  
    set proposedCalls(value: Array<string>) {
      this.set("proposedCalls", Value.fromStringArray(value));
    }
  
    get asOwnable(): Bytes | null {
      let value = this.get("asOwnable");
      if (!value || value.kind == ValueKind.NULL) {
        return null;
      } else {
        return value.toBytes();
      }
    }
  
    set asOwnable(value: Bytes | null) {
      if (!value) {
        this.unset("asOwnable");
      } else {
        this.set("asOwnable", Value.fromBytes(<Bytes>value));
      }
    }
  
    get ownerOf(): Array<Bytes> {
      let value = this.get("ownerOf");
      return value!.toBytesArray();
    }
  
    set ownerOf(value: Array<Bytes>) {
      this.set("ownerOf", Value.fromBytesArray(value));
    }
  
    get ownershipTransferred(): Array<string> {
      let value = this.get("ownershipTransferred");
      return value!.toStringArray();
    }
  
    set ownershipTransferred(value: Array<string>) {
      this.set("ownershipTransferred", Value.fromStringArray(value));
    }
  
    get asPausable(): Bytes | null {
      let value = this.get("asPausable");
      if (!value || value.kind == ValueKind.NULL) {
        return null;
      } else {
        return value.toBytes();
      }
    }
  
    set asPausable(value: Bytes | null) {
      if (!value) {
        this.unset("asPausable");
      } else {
        this.set("asPausable", Value.fromBytes(<Bytes>value));
      }
    }
  
    get asTimelock(): Bytes | null {
      let value = this.get("asTimelock");
      if (!value || value.kind == ValueKind.NULL) {
        return null;
      } else {
        return value.toBytes();
      }
    }
  
    set asTimelock(value: Bytes | null) {
      if (!value) {
        this.unset("asTimelock");
      } else {
        this.set("asTimelock", Value.fromBytes(<Bytes>value));
      }
    }
  
    get timelockedCalls(): Array<string> {
      let value = this.get("timelockedCalls");
      return value!.toStringArray();
    }
  
    set timelockedCalls(value: Array<string>) {
      this.set("timelockedCalls", Value.fromStringArray(value));
    }
  
    get asVoting(): Bytes | null {
      let value = this.get("asVoting");
      if (!value || value.kind == ValueKind.NULL) {
        return null;
      } else {
        return value.toBytes();
      }
    }
  
    set asVoting(value: Bytes | null) {
      if (!value) {
        this.unset("asVoting");
      } else {
        this.set("asVoting", Value.fromBytes(<Bytes>value));
      }
    }
  
    get delegationFrom(): Array<string> {
      let value = this.get("delegationFrom");
      return value!.toStringArray();
    }
  
    set delegationFrom(value: Array<string>) {
      this.set("delegationFrom", Value.fromStringArray(value));
    }
  
    get delegationTo(): Array<string> {
      let value = this.get("delegationTo");
      return value!.toStringArray();
    }
  
    set delegationTo(value: Array<string>) {
      this.set("delegationTo", Value.fromStringArray(value));
    }
  
    get voteWeigth(): Array<string> {
      let value = this.get("voteWeigth");
      return value!.toStringArray();
    }
  
    set voteWeigth(value: Array<string>) {
      this.set("voteWeigth", Value.fromStringArray(value));
    }
  
    get delegateChangedEvent(): Array<string> {
      let value = this.get("delegateChangedEvent");
      return value!.toStringArray();
    }
  
    set delegateChangedEvent(value: Array<string>) {
      this.set("delegateChangedEvent", Value.fromStringArray(value));
    }
  
    get delegateChangedFromEvent(): Array<string> {
      let value = this.get("delegateChangedFromEvent");
      return value!.toStringArray();
    }
  
    set delegateChangedFromEvent(value: Array<string>) {
      this.set("delegateChangedFromEvent", Value.fromStringArray(value));
    }
  
    get delegateChangedToEvent(): Array<string> {
      let value = this.get("delegateChangedToEvent");
      return value!.toStringArray();
    }
  
    set delegateChangedToEvent(value: Array<string>) {
      this.set("delegateChangedToEvent", Value.fromStringArray(value));
    }
  
    get delegateVotesChangedEvent(): Array<string> {
      let value = this.get("delegateVotesChangedEvent");
      return value!.toStringArray();
    }
  
    set delegateVotesChangedEvent(value: Array<string>) {
      this.set("delegateVotesChangedEvent", Value.fromStringArray(value));
    }
  
    get events(): Array<string> {
      let value = this.get("events");
      return value!.toStringArray();
    }
  
    set events(value: Array<string>) {
      this.set("events", Value.fromStringArray(value));
    }
  }
  
  export class AccessControl extends Entity {
    constructor(id: Bytes) {
      super();
      this.set("id", Value.fromBytes(id));
    }
  
    save(): void {
      let id = this.get("id");
      assert(id != null, "Cannot save AccessControl entity without an ID");
      if (id) {
        assert(
          id.kind == ValueKind.BYTES,
          `Entities of type AccessControl must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
        );
        store.set("AccessControl", id.toBytes().toHexString(), this);
      }
    }
  
    static load(id: Bytes): AccessControl | null {
      return changetype<AccessControl | null>(
        store.get("AccessControl", id.toHexString())
      );
    }
  
    get id(): Bytes {
      let value = this.get("id");
      return value!.toBytes();
    }
  
    set id(value: Bytes) {
      this.set("id", Value.fromBytes(value));
    }
  
    get asAccount(): Bytes {
      let value = this.get("asAccount");
      return value!.toBytes();
    }
  
    set asAccount(value: Bytes) {
      this.set("asAccount", Value.fromBytes(value));
    }
  
    get roles(): Array<string> {
      let value = this.get("roles");
      return value!.toStringArray();
    }
  
    set roles(value: Array<string>) {
      this.set("roles", Value.fromStringArray(value));
    }
  }
  
  export class Role extends Entity {
    constructor(id: Bytes) {
      super();
      this.set("id", Value.fromBytes(id));
    }
  
    save(): void {
      let id = this.get("id");
      assert(id != null, "Cannot save Role entity without an ID");
      if (id) {
        assert(
          id.kind == ValueKind.BYTES,
          `Entities of type Role must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
        );
        store.set("Role", id.toBytes().toHexString(), this);
      }
    }
  
    static load(id: Bytes): Role | null {
      return changetype<Role | null>(store.get("Role", id.toHexString()));
    }
  
    get id(): Bytes {
      let value = this.get("id");
      return value!.toBytes();
    }
  
    set id(value: Bytes) {
      this.set("id", Value.fromBytes(value));
    }
  
    get roleOf(): Array<string> {
      let value = this.get("roleOf");
      return value!.toStringArray();
    }
  
    set roleOf(value: Array<string>) {
      this.set("roleOf", Value.fromStringArray(value));
    }
  }
  
  export class AccessControlRole extends Entity {
    constructor(id: string) {
      super();
      this.set("id", Value.fromString(id));
    }
  
    save(): void {
      let id = this.get("id");
      assert(id != null, "Cannot save AccessControlRole entity without an ID");
      if (id) {
        assert(
          id.kind == ValueKind.STRING,
          `Entities of type AccessControlRole must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
        );
        store.set("AccessControlRole", id.toString(), this);
      }
    }
  
    static load(id: string): AccessControlRole | null {
      return changetype<AccessControlRole | null>(
        store.get("AccessControlRole", id)
      );
    }
  
    get id(): string {
      let value = this.get("id");
      return value!.toString();
    }
  
    set id(value: string) {
      this.set("id", Value.fromString(value));
    }
  
    get contract(): Bytes {
      let value = this.get("contract");
      return value!.toBytes();
    }
  
    set contract(value: Bytes) {
      this.set("contract", Value.fromBytes(value));
    }
  
    get role(): Bytes {
      let value = this.get("role");
      return value!.toBytes();
    }
  
    set role(value: Bytes) {
      this.set("role", Value.fromBytes(value));
    }
  
    get admin(): string {
      let value = this.get("admin");
      return value!.toString();
    }
  
    set admin(value: string) {
      this.set("admin", Value.fromString(value));
    }
  
    get adminOf(): Array<string> {
      let value = this.get("adminOf");
      return value!.toStringArray();
    }
  
    set adminOf(value: Array<string>) {
      this.set("adminOf", Value.fromStringArray(value));
    }
  
    get members(): Array<string> {
      let value = this.get("members");
      return value!.toStringArray();
    }
  
    set members(value: Array<string>) {
      this.set("members", Value.fromStringArray(value));
    }
  
    get roleGranted(): Array<string> {
      let value = this.get("roleGranted");
      return value!.toStringArray();
    }
  
    set roleGranted(value: Array<string>) {
      this.set("roleGranted", Value.fromStringArray(value));
    }
  
    get roleRevoked(): Array<string> {
      let value = this.get("roleRevoked");
      return value!.toStringArray();
    }
  
    set roleRevoked(value: Array<string>) {
      this.set("roleRevoked", Value.fromStringArray(value));
    }
  
    get roleAdminChanged(): Array<string> {
      let value = this.get("roleAdminChanged");
      return value!.toStringArray();
    }
  
    set roleAdminChanged(value: Array<string>) {
      this.set("roleAdminChanged", Value.fromStringArray(value));
    }
  }
  
  export class AccessControlRoleMember extends Entity {
    constructor(id: string) {
      super();
      this.set("id", Value.fromString(id));
    }
  
    save(): void {
      let id = this.get("id");
      assert(
        id != null,
        "Cannot save AccessControlRoleMember entity without an ID"
      );
      if (id) {
        assert(
          id.kind == ValueKind.STRING,
          `Entities of type AccessControlRoleMember must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
        );
        store.set("AccessControlRoleMember", id.toString(), this);
      }
    }
  
    static load(id: string): AccessControlRoleMember | null {
      return changetype<AccessControlRoleMember | null>(
        store.get("AccessControlRoleMember", id)
      );
    }
  
    get id(): string {
      let value = this.get("id");
      return value!.toString();
    }
  
    set id(value: string) {
      this.set("id", Value.fromString(value));
    }
  
    get accesscontrolrole(): string {
      let value = this.get("accesscontrolrole");
      return value!.toString();
    }
  
    set accesscontrolrole(value: string) {
      this.set("accesscontrolrole", Value.fromString(value));
    }
  
    get account(): Bytes {
      let value = this.get("account");
      return value!.toBytes();
    }
  
    set account(value: Bytes) {
      this.set("account", Value.fromBytes(value));
    }
  }
  
  export class RoleAdminChanged extends Entity {
    constructor(id: string) {
      super();
      this.set("id", Value.fromString(id));
    }
  
    save(): void {
      let id = this.get("id");
      assert(id != null, "Cannot save RoleAdminChanged entity without an ID");
      if (id) {
        assert(
          id.kind == ValueKind.STRING,
          `Entities of type RoleAdminChanged must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
        );
        store.set("RoleAdminChanged", id.toString(), this);
      }
    }
  
    static load(id: string): RoleAdminChanged | null {
      return changetype<RoleAdminChanged | null>(
        store.get("RoleAdminChanged", id)
      );
    }
  
    get id(): string {
      let value = this.get("id");
      return value!.toString();
    }
  
    set id(value: string) {
      this.set("id", Value.fromString(value));
    }
  
    get emitter(): Bytes {
      let value = this.get("emitter");
      return value!.toBytes();
    }
  
    set emitter(value: Bytes) {
      this.set("emitter", Value.fromBytes(value));
    }
  
    get transaction(): string {
      let value = this.get("transaction");
      return value!.toString();
    }
  
    set transaction(value: string) {
      this.set("transaction", Value.fromString(value));
    }
  
    get timestamp(): BigInt {
      let value = this.get("timestamp");
      return value!.toBigInt();
    }
  
    set timestamp(value: BigInt) {
      this.set("timestamp", Value.fromBigInt(value));
    }
  
    get role(): string {
      let value = this.get("role");
      return value!.toString();
    }
  
    set role(value: string) {
      this.set("role", Value.fromString(value));
    }
  
    get newAdminRole(): string {
      let value = this.get("newAdminRole");
      return value!.toString();
    }
  
    set newAdminRole(value: string) {
      this.set("newAdminRole", Value.fromString(value));
    }
  
    get previousAdminRole(): string {
      let value = this.get("previousAdminRole");
      return value!.toString();
    }
  
    set previousAdminRole(value: string) {
      this.set("previousAdminRole", Value.fromString(value));
    }
  }
  
  export class RoleGranted extends Entity {
    constructor(id: string) {
      super();
      this.set("id", Value.fromString(id));
    }
  
    save(): void {
      let id = this.get("id");
      assert(id != null, "Cannot save RoleGranted entity without an ID");
      if (id) {
        assert(
          id.kind == ValueKind.STRING,
          `Entities of type RoleGranted must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
        );
        store.set("RoleGranted", id.toString(), this);
      }
    }
  
    static load(id: string): RoleGranted | null {
      return changetype<RoleGranted | null>(store.get("RoleGranted", id));
    }
  
    get id(): string {
      let value = this.get("id");
      return value!.toString();
    }
  
    set id(value: string) {
      this.set("id", Value.fromString(value));
    }
  
    get emitter(): Bytes {
      let value = this.get("emitter");
      return value!.toBytes();
    }
  
    set emitter(value: Bytes) {
      this.set("emitter", Value.fromBytes(value));
    }
  
    get transaction(): string {
      let value = this.get("transaction");
      return value!.toString();
    }
  
    set transaction(value: string) {
      this.set("transaction", Value.fromString(value));
    }
  
    get timestamp(): BigInt {
      let value = this.get("timestamp");
      return value!.toBigInt();
    }
  
    set timestamp(value: BigInt) {
      this.set("timestamp", Value.fromBigInt(value));
    }
  
    get role(): string {
      let value = this.get("role");
      return value!.toString();
    }
  
    set role(value: string) {
      this.set("role", Value.fromString(value));
    }
  
    get account(): Bytes {
      let value = this.get("account");
      return value!.toBytes();
    }
  
    set account(value: Bytes) {
      this.set("account", Value.fromBytes(value));
    }
  
    get sender(): Bytes {
      let value = this.get("sender");
      return value!.toBytes();
    }
  
    set sender(value: Bytes) {
      this.set("sender", Value.fromBytes(value));
    }
  }
  
  export class RoleRevoked extends Entity {
    constructor(id: string) {
      super();
      this.set("id", Value.fromString(id));
    }
  
    save(): void {
      let id = this.get("id");
      assert(id != null, "Cannot save RoleRevoked entity without an ID");
      if (id) {
        assert(
          id.kind == ValueKind.STRING,
          `Entities of type RoleRevoked must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
        );
        store.set("RoleRevoked", id.toString(), this);
      }
    }
  
    static load(id: string): RoleRevoked | null {
      return changetype<RoleRevoked | null>(store.get("RoleRevoked", id));
    }
  
    get id(): string {
      let value = this.get("id");
      return value!.toString();
    }
  
    set id(value: string) {
      this.set("id", Value.fromString(value));
    }
  
    get emitter(): Bytes {
      let value = this.get("emitter");
      return value!.toBytes();
    }
  
    set emitter(value: Bytes) {
      this.set("emitter", Value.fromBytes(value));
    }
  
    get transaction(): string {
      let value = this.get("transaction");
      return value!.toString();
    }
  
    set transaction(value: string) {
      this.set("transaction", Value.fromString(value));
    }
  
    get timestamp(): BigInt {
      let value = this.get("timestamp");
      return value!.toBigInt();
    }
  
    set timestamp(value: BigInt) {
      this.set("timestamp", Value.fromBigInt(value));
    }
  
    get role(): string {
      let value = this.get("role");
      return value!.toString();
    }
  
    set role(value: string) {
      this.set("role", Value.fromString(value));
    }
  
    get account(): Bytes {
      let value = this.get("account");
      return value!.toBytes();
    }
  
    set account(value: Bytes) {
      this.set("account", Value.fromBytes(value));
    }
  
    get sender(): Bytes {
      let value = this.get("sender");
      return value!.toBytes();
    }
  
    set sender(value: Bytes) {
      this.set("sender", Value.fromBytes(value));
    }
  }
  
  export class ERC1155Contract extends Entity {
    constructor(id: Bytes) {
      super();
      this.set("id", Value.fromBytes(id));
    }
  
    save(): void {
      let id = this.get("id");
      assert(id != null, "Cannot save ERC1155Contract entity without an ID");
      if (id) {
        assert(
          id.kind == ValueKind.BYTES,
          `Entities of type ERC1155Contract must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
        );
        store.set("ERC1155Contract", id.toBytes().toHexString(), this);
      }
    }
  
    static load(id: Bytes): ERC1155Contract | null {
      return changetype<ERC1155Contract | null>(
        store.get("ERC1155Contract", id.toHexString())
      );
    }
  
    get id(): Bytes {
      let value = this.get("id");
      return value!.toBytes();
    }
  
    set id(value: Bytes) {
      this.set("id", Value.fromBytes(value));
    }
  
    get asAccount(): Bytes {
      let value = this.get("asAccount");
      return value!.toBytes();
    }
  
    set asAccount(value: Bytes) {
      this.set("asAccount", Value.fromBytes(value));
    }
  
    get tokens(): Array<string> {
      let value = this.get("tokens");
      return value!.toStringArray();
    }
  
    set tokens(value: Array<string>) {
      this.set("tokens", Value.fromStringArray(value));
    }
  
    get balances(): Array<string> {
      let value = this.get("balances");
      return value!.toStringArray();
    }
  
    set balances(value: Array<string>) {
      this.set("balances", Value.fromStringArray(value));
    }
  
    get operators(): Array<string> {
      let value = this.get("operators");
      return value!.toStringArray();
    }
  
    set operators(value: Array<string>) {
      this.set("operators", Value.fromStringArray(value));
    }
  
    get transfers(): Array<string> {
      let value = this.get("transfers");
      return value!.toStringArray();
    }
  
    set transfers(value: Array<string>) {
      this.set("transfers", Value.fromStringArray(value));
    }
  }
  
  export class ERC1155Token extends Entity {
    constructor(id: string) {
      super();
      this.set("id", Value.fromString(id));
    }
  
    save(): void {
      let id = this.get("id");
      assert(id != null, "Cannot save ERC1155Token entity without an ID");
      if (id) {
        assert(
          id.kind == ValueKind.STRING,
          `Entities of type ERC1155Token must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
        );
        store.set("ERC1155Token", id.toString(), this);
      }
    }
  
    static load(id: string): ERC1155Token | null {
      return changetype<ERC1155Token | null>(store.get("ERC1155Token", id));
    }
  
    get id(): string {
      let value = this.get("id");
      return value!.toString();
    }
  
    set id(value: string) {
      this.set("id", Value.fromString(value));
    }
  
    get contract(): Bytes {
      let value = this.get("contract");
      return value!.toBytes();
    }
  
    set contract(value: Bytes) {
      this.set("contract", Value.fromBytes(value));
    }
  
    get identifier(): BigInt {
      let value = this.get("identifier");
      return value!.toBigInt();
    }
  
    set identifier(value: BigInt) {
      this.set("identifier", Value.fromBigInt(value));
    }
  
    get uri(): string | null {
      let value = this.get("uri");
      if (!value || value.kind == ValueKind.NULL) {
        return null;
      } else {
        return value.toString();
      }
    }
  
    set uri(value: string | null) {
      if (!value) {
        this.unset("uri");
      } else {
        this.set("uri", Value.fromString(<string>value));
      }
    }
  
    get totalSupply(): string {
      let value = this.get("totalSupply");
      return value!.toString();
    }
  
    set totalSupply(value: string) {
      this.set("totalSupply", Value.fromString(value));
    }
  
    get balances(): Array<string> {
      let value = this.get("balances");
      return value!.toStringArray();
    }
  
    set balances(value: Array<string>) {
      this.set("balances", Value.fromStringArray(value));
    }
  
    get transfers(): Array<string> {
      let value = this.get("transfers");
      return value!.toStringArray();
    }
  
    set transfers(value: Array<string>) {
      this.set("transfers", Value.fromStringArray(value));
    }
  }
  
  export class ERC1155Balance extends Entity {
    constructor(id: string) {
      super();
      this.set("id", Value.fromString(id));
    }
  
    save(): void {
      let id = this.get("id");
      assert(id != null, "Cannot save ERC1155Balance entity without an ID");
      if (id) {
        assert(
          id.kind == ValueKind.STRING,
          `Entities of type ERC1155Balance must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
        );
        store.set("ERC1155Balance", id.toString(), this);
      }
    }
  
    static load(id: string): ERC1155Balance | null {
      return changetype<ERC1155Balance | null>(store.get("ERC1155Balance", id));
    }
  
    get id(): string {
      let value = this.get("id");
      return value!.toString();
    }
  
    set id(value: string) {
      this.set("id", Value.fromString(value));
    }
  
    get contract(): Bytes {
      let value = this.get("contract");
      return value!.toBytes();
    }
  
    set contract(value: Bytes) {
      this.set("contract", Value.fromBytes(value));
    }
  
    get token(): string {
      let value = this.get("token");
      return value!.toString();
    }
  
    set token(value: string) {
      this.set("token", Value.fromString(value));
    }
  
    get account(): Bytes | null {
      let value = this.get("account");
      if (!value || value.kind == ValueKind.NULL) {
        return null;
      } else {
        return value.toBytes();
      }
    }
  
    set account(value: Bytes | null) {
      if (!value) {
        this.unset("account");
      } else {
        this.set("account", Value.fromBytes(<Bytes>value));
      }
    }
  
    get value(): BigDecimal {
      let value = this.get("value");
      return value!.toBigDecimal();
    }
  
    set value(value: BigDecimal) {
      this.set("value", Value.fromBigDecimal(value));
    }
  
    get valueExact(): BigInt {
      let value = this.get("valueExact");
      return value!.toBigInt();
    }
  
    set valueExact(value: BigInt) {
      this.set("valueExact", Value.fromBigInt(value));
    }
  
    get transferFromEvent(): Array<string> {
      let value = this.get("transferFromEvent");
      return value!.toStringArray();
    }
  
    set transferFromEvent(value: Array<string>) {
      this.set("transferFromEvent", Value.fromStringArray(value));
    }
  
    get transferToEvent(): Array<string> {
      let value = this.get("transferToEvent");
      return value!.toStringArray();
    }
  
    set transferToEvent(value: Array<string>) {
      this.set("transferToEvent", Value.fromStringArray(value));
    }
  }
  
  export class ERC1155Operator extends Entity {
    constructor(id: string) {
      super();
      this.set("id", Value.fromString(id));
    }
  
    save(): void {
      let id = this.get("id");
      assert(id != null, "Cannot save ERC1155Operator entity without an ID");
      if (id) {
        assert(
          id.kind == ValueKind.STRING,
          `Entities of type ERC1155Operator must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
        );
        store.set("ERC1155Operator", id.toString(), this);
      }
    }
  
    static load(id: string): ERC1155Operator | null {
      return changetype<ERC1155Operator | null>(store.get("ERC1155Operator", id));
    }
  
    get id(): string {
      let value = this.get("id");
      return value!.toString();
    }
  
    set id(value: string) {
      this.set("id", Value.fromString(value));
    }
  
    get contract(): Bytes {
      let value = this.get("contract");
      return value!.toBytes();
    }
  
    set contract(value: Bytes) {
      this.set("contract", Value.fromBytes(value));
    }
  
    get owner(): Bytes {
      let value = this.get("owner");
      return value!.toBytes();
    }
  
    set owner(value: Bytes) {
      this.set("owner", Value.fromBytes(value));
    }
  
    get operator(): Bytes {
      let value = this.get("operator");
      return value!.toBytes();
    }
  
    set operator(value: Bytes) {
      this.set("operator", Value.fromBytes(value));
    }
  
    get approved(): boolean {
      let value = this.get("approved");
      return value!.toBoolean();
    }
  
    set approved(value: boolean) {
      this.set("approved", Value.fromBoolean(value));
    }
  }
  
  export class ERC1155Transfer extends Entity {
    constructor(id: string) {
      super();
      this.set("id", Value.fromString(id));
    }
  
    save(): void {
      let id = this.get("id");
      assert(id != null, "Cannot save ERC1155Transfer entity without an ID");
      if (id) {
        assert(
          id.kind == ValueKind.STRING,
          `Entities of type ERC1155Transfer must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
        );
        store.set("ERC1155Transfer", id.toString(), this);
      }
    }
  
    static load(id: string): ERC1155Transfer | null {
      return changetype<ERC1155Transfer | null>(store.get("ERC1155Transfer", id));
    }
  
    get id(): string {
      let value = this.get("id");
      return value!.toString();
    }
  
    set id(value: string) {
      this.set("id", Value.fromString(value));
    }
  
    get emitter(): Bytes {
      let value = this.get("emitter");
      return value!.toBytes();
    }
  
    set emitter(value: Bytes) {
      this.set("emitter", Value.fromBytes(value));
    }
  
    get transaction(): string {
      let value = this.get("transaction");
      return value!.toString();
    }
  
    set transaction(value: string) {
      this.set("transaction", Value.fromString(value));
    }
  
    get timestamp(): BigInt {
      let value = this.get("timestamp");
      return value!.toBigInt();
    }
  
    set timestamp(value: BigInt) {
      this.set("timestamp", Value.fromBigInt(value));
    }
  
    get contract(): Bytes {
      let value = this.get("contract");
      return value!.toBytes();
    }
  
    set contract(value: Bytes) {
      this.set("contract", Value.fromBytes(value));
    }
  
    get token(): string {
      let value = this.get("token");
      return value!.toString();
    }
  
    set token(value: string) {
      this.set("token", Value.fromString(value));
    }
  
    get operator(): Bytes {
      let value = this.get("operator");
      return value!.toBytes();
    }
  
    set operator(value: Bytes) {
      this.set("operator", Value.fromBytes(value));
    }
  
    get from(): Bytes | null {
      let value = this.get("from");
      if (!value || value.kind == ValueKind.NULL) {
        return null;
      } else {
        return value.toBytes();
      }
    }
  
    set from(value: Bytes | null) {
      if (!value) {
        this.unset("from");
      } else {
        this.set("from", Value.fromBytes(<Bytes>value));
      }
    }
  
    get fromBalance(): string | null {
      let value = this.get("fromBalance");
      if (!value || value.kind == ValueKind.NULL) {
        return null;
      } else {
        return value.toString();
      }
    }
  
    set fromBalance(value: string | null) {
      if (!value) {
        this.unset("fromBalance");
      } else {
        this.set("fromBalance", Value.fromString(<string>value));
      }
    }
  
    get to(): Bytes | null {
      let value = this.get("to");
      if (!value || value.kind == ValueKind.NULL) {
        return null;
      } else {
        return value.toBytes();
      }
    }
  
    set to(value: Bytes | null) {
      if (!value) {
        this.unset("to");
      } else {
        this.set("to", Value.fromBytes(<Bytes>value));
      }
    }
  
    get toBalance(): string | null {
      let value = this.get("toBalance");
      if (!value || value.kind == ValueKind.NULL) {
        return null;
      } else {
        return value.toString();
      }
    }
  
    set toBalance(value: string | null) {
      if (!value) {
        this.unset("toBalance");
      } else {
        this.set("toBalance", Value.fromString(<string>value));
      }
    }
  
    get value(): BigDecimal {
      let value = this.get("value");
      return value!.toBigDecimal();
    }
  
    set value(value: BigDecimal) {
      this.set("value", Value.fromBigDecimal(value));
    }
  
    get valueExact(): BigInt {
      let value = this.get("valueExact");
      return value!.toBigInt();
    }
  
    set valueExact(value: BigInt) {
      this.set("valueExact", Value.fromBigInt(value));
    }
  }
  
  export class ERC1967AdminChanged extends Entity {
    constructor(id: string) {
      super();
      this.set("id", Value.fromString(id));
    }
  
    save(): void {
      let id = this.get("id");
      assert(id != null, "Cannot save ERC1967AdminChanged entity without an ID");
      if (id) {
        assert(
          id.kind == ValueKind.STRING,
          `Entities of type ERC1967AdminChanged must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
        );
        store.set("ERC1967AdminChanged", id.toString(), this);
      }
    }
  
    static load(id: string): ERC1967AdminChanged | null {
      return changetype<ERC1967AdminChanged | null>(
        store.get("ERC1967AdminChanged", id)
      );
    }
  
    get id(): string {
      let value = this.get("id");
      return value!.toString();
    }
  
    set id(value: string) {
      this.set("id", Value.fromString(value));
    }
  
    get emitter(): Bytes {
      let value = this.get("emitter");
      return value!.toBytes();
    }
  
    set emitter(value: Bytes) {
      this.set("emitter", Value.fromBytes(value));
    }
  
    get transaction(): string {
      let value = this.get("transaction");
      return value!.toString();
    }
  
    set transaction(value: string) {
      this.set("transaction", Value.fromString(value));
    }
  
    get timestamp(): BigInt {
      let value = this.get("timestamp");
      return value!.toBigInt();
    }
  
    set timestamp(value: BigInt) {
      this.set("timestamp", Value.fromBigInt(value));
    }
  
    get admin(): Bytes {
      let value = this.get("admin");
      return value!.toBytes();
    }
  
    set admin(value: Bytes) {
      this.set("admin", Value.fromBytes(value));
    }
  }
  
  export class ERC1967BeaconUpgraded extends Entity {
    constructor(id: string) {
      super();
      this.set("id", Value.fromString(id));
    }
  
    save(): void {
      let id = this.get("id");
      assert(
        id != null,
        "Cannot save ERC1967BeaconUpgraded entity without an ID"
      );
      if (id) {
        assert(
          id.kind == ValueKind.STRING,
          `Entities of type ERC1967BeaconUpgraded must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
        );
        store.set("ERC1967BeaconUpgraded", id.toString(), this);
      }
    }
  
    static load(id: string): ERC1967BeaconUpgraded | null {
      return changetype<ERC1967BeaconUpgraded | null>(
        store.get("ERC1967BeaconUpgraded", id)
      );
    }
  
    get id(): string {
      let value = this.get("id");
      return value!.toString();
    }
  
    set id(value: string) {
      this.set("id", Value.fromString(value));
    }
  
    get emitter(): Bytes {
      let value = this.get("emitter");
      return value!.toBytes();
    }
  
    set emitter(value: Bytes) {
      this.set("emitter", Value.fromBytes(value));
    }
  
    get transaction(): string {
      let value = this.get("transaction");
      return value!.toString();
    }
  
    set transaction(value: string) {
      this.set("transaction", Value.fromString(value));
    }
  
    get timestamp(): BigInt {
      let value = this.get("timestamp");
      return value!.toBigInt();
    }
  
    set timestamp(value: BigInt) {
      this.set("timestamp", Value.fromBigInt(value));
    }
  
    get beacon(): Bytes {
      let value = this.get("beacon");
      return value!.toBytes();
    }
  
    set beacon(value: Bytes) {
      this.set("beacon", Value.fromBytes(value));
    }
  }
  
  export class ERC1967ImplementationUpgraded extends Entity {
    constructor(id: string) {
      super();
      this.set("id", Value.fromString(id));
    }
  
    save(): void {
      let id = this.get("id");
      assert(
        id != null,
        "Cannot save ERC1967ImplementationUpgraded entity without an ID"
      );
      if (id) {
        assert(
          id.kind == ValueKind.STRING,
          `Entities of type ERC1967ImplementationUpgraded must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
        );
        store.set("ERC1967ImplementationUpgraded", id.toString(), this);
      }
    }
  
    static load(id: string): ERC1967ImplementationUpgraded | null {
      return changetype<ERC1967ImplementationUpgraded | null>(
        store.get("ERC1967ImplementationUpgraded", id)
      );
    }
  
    get id(): string {
      let value = this.get("id");
      return value!.toString();
    }
  
    set id(value: string) {
      this.set("id", Value.fromString(value));
    }
  
    get emitter(): Bytes {
      let value = this.get("emitter");
      return value!.toBytes();
    }
  
    set emitter(value: Bytes) {
      this.set("emitter", Value.fromBytes(value));
    }
  
    get transaction(): string {
      let value = this.get("transaction");
      return value!.toString();
    }
  
    set transaction(value: string) {
      this.set("transaction", Value.fromString(value));
    }
  
    get timestamp(): BigInt {
      let value = this.get("timestamp");
      return value!.toBigInt();
    }
  
    set timestamp(value: BigInt) {
      this.set("timestamp", Value.fromBigInt(value));
    }
  
    get implementation(): Bytes {
      let value = this.get("implementation");
      return value!.toBytes();
    }
  
    set implementation(value: Bytes) {
      this.set("implementation", Value.fromBytes(value));
    }
  }
  
  export class ERC20Contract extends Entity {
    constructor(id: Bytes) {
      super();
      this.set("id", Value.fromBytes(id));
    }
  
    save(): void {
      let id = this.get("id");
      assert(id != null, "Cannot save ERC20Contract entity without an ID");
      if (id) {
        assert(
          id.kind == ValueKind.BYTES,
          `Entities of type ERC20Contract must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
        );
        store.set("ERC20Contract", id.toBytes().toHexString(), this);
      }
    }
  
    static load(id: Bytes): ERC20Contract | null {
      return changetype<ERC20Contract | null>(
        store.get("ERC20Contract", id.toHexString())
      );
    }
  
    get id(): Bytes {
      let value = this.get("id");
      return value!.toBytes();
    }
  
    set id(value: Bytes) {
      this.set("id", Value.fromBytes(value));
    }
  
    get asAccount(): Bytes {
      let value = this.get("asAccount");
      return value!.toBytes();
    }
  
    set asAccount(value: Bytes) {
      this.set("asAccount", Value.fromBytes(value));
    }
  
    get name(): string | null {
      let value = this.get("name");
      if (!value || value.kind == ValueKind.NULL) {
        return null;
      } else {
        return value.toString();
      }
    }
  
    set name(value: string | null) {
      if (!value) {
        this.unset("name");
      } else {
        this.set("name", Value.fromString(<string>value));
      }
    }
  
    get symbol(): string | null {
      let value = this.get("symbol");
      if (!value || value.kind == ValueKind.NULL) {
        return null;
      } else {
        return value.toString();
      }
    }
  
    set symbol(value: string | null) {
      if (!value) {
        this.unset("symbol");
      } else {
        this.set("symbol", Value.fromString(<string>value));
      }
    }
  
    get decimals(): i32 {
      let value = this.get("decimals");
      return value!.toI32();
    }
  
    set decimals(value: i32) {
      this.set("decimals", Value.fromI32(value));
    }
  
    get totalSupply(): string {
      let value = this.get("totalSupply");
      return value!.toString();
    }
  
    set totalSupply(value: string) {
      this.set("totalSupply", Value.fromString(value));
    }
  
    get balances(): Array<string> {
      let value = this.get("balances");
      return value!.toStringArray();
    }
  
    set balances(value: Array<string>) {
      this.set("balances", Value.fromStringArray(value));
    }
  
    get approvals(): Array<string> {
      let value = this.get("approvals");
      return value!.toStringArray();
    }
  
    set approvals(value: Array<string>) {
      this.set("approvals", Value.fromStringArray(value));
    }
  
    get transfers(): Array<string> {
      let value = this.get("transfers");
      return value!.toStringArray();
    }
  
    set transfers(value: Array<string>) {
      this.set("transfers", Value.fromStringArray(value));
    }
  }
  
  export class ERC20Balance extends Entity {
    constructor(id: string) {
      super();
      this.set("id", Value.fromString(id));
    }
  
    save(): void {
      let id = this.get("id");
      assert(id != null, "Cannot save ERC20Balance entity without an ID");
      if (id) {
        assert(
          id.kind == ValueKind.STRING,
          `Entities of type ERC20Balance must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
        );
        store.set("ERC20Balance", id.toString(), this);
      }
    }
  
    static load(id: string): ERC20Balance | null {
      return changetype<ERC20Balance | null>(store.get("ERC20Balance", id));
    }
  
    get id(): string {
      let value = this.get("id");
      return value!.toString();
    }
  
    set id(value: string) {
      this.set("id", Value.fromString(value));
    }
  
    get contract(): Bytes {
      let value = this.get("contract");
      return value!.toBytes();
    }
  
    set contract(value: Bytes) {
      this.set("contract", Value.fromBytes(value));
    }
  
    get account(): Bytes | null {
      let value = this.get("account");
      if (!value || value.kind == ValueKind.NULL) {
        return null;
      } else {
        return value.toBytes();
      }
    }
  
    set account(value: Bytes | null) {
      if (!value) {
        this.unset("account");
      } else {
        this.set("account", Value.fromBytes(<Bytes>value));
      }
    }
  
    get value(): BigDecimal {
      let value = this.get("value");
      return value!.toBigDecimal();
    }
  
    set value(value: BigDecimal) {
      this.set("value", Value.fromBigDecimal(value));
    }
  
    get valueExact(): BigInt {
      let value = this.get("valueExact");
      return value!.toBigInt();
    }
  
    set valueExact(value: BigInt) {
      this.set("valueExact", Value.fromBigInt(value));
    }
  
    get transferFromEvent(): Array<string> {
      let value = this.get("transferFromEvent");
      return value!.toStringArray();
    }
  
    set transferFromEvent(value: Array<string>) {
      this.set("transferFromEvent", Value.fromStringArray(value));
    }
  
    get transferToEvent(): Array<string> {
      let value = this.get("transferToEvent");
      return value!.toStringArray();
    }
  
    set transferToEvent(value: Array<string>) {
      this.set("transferToEvent", Value.fromStringArray(value));
    }
  }
  
  export class ERC20Approval extends Entity {
    constructor(id: string) {
      super();
      this.set("id", Value.fromString(id));
    }
  
    save(): void {
      let id = this.get("id");
      assert(id != null, "Cannot save ERC20Approval entity without an ID");
      if (id) {
        assert(
          id.kind == ValueKind.STRING,
          `Entities of type ERC20Approval must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
        );
        store.set("ERC20Approval", id.toString(), this);
      }
    }
  
    static load(id: string): ERC20Approval | null {
      return changetype<ERC20Approval | null>(store.get("ERC20Approval", id));
    }
  
    get id(): string {
      let value = this.get("id");
      return value!.toString();
    }
  
    set id(value: string) {
      this.set("id", Value.fromString(value));
    }
  
    get contract(): Bytes {
      let value = this.get("contract");
      return value!.toBytes();
    }
  
    set contract(value: Bytes) {
      this.set("contract", Value.fromBytes(value));
    }
  
    get owner(): Bytes {
      let value = this.get("owner");
      return value!.toBytes();
    }
  
    set owner(value: Bytes) {
      this.set("owner", Value.fromBytes(value));
    }
  
    get spender(): Bytes {
      let value = this.get("spender");
      return value!.toBytes();
    }
  
    set spender(value: Bytes) {
      this.set("spender", Value.fromBytes(value));
    }
  
    get value(): BigDecimal {
      let value = this.get("value");
      return value!.toBigDecimal();
    }
  
    set value(value: BigDecimal) {
      this.set("value", Value.fromBigDecimal(value));
    }
  
    get valueExact(): BigInt {
      let value = this.get("valueExact");
      return value!.toBigInt();
    }
  
    set valueExact(value: BigInt) {
      this.set("valueExact", Value.fromBigInt(value));
    }
  }
  
  export class ERC20Transfer extends Entity {
    constructor(id: string) {
      super();
      this.set("id", Value.fromString(id));
    }
  
    save(): void {
      let id = this.get("id");
      assert(id != null, "Cannot save ERC20Transfer entity without an ID");
      if (id) {
        assert(
          id.kind == ValueKind.STRING,
          `Entities of type ERC20Transfer must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
        );
        store.set("ERC20Transfer", id.toString(), this);
      }
    }
  
    static load(id: string): ERC20Transfer | null {
      return changetype<ERC20Transfer | null>(store.get("ERC20Transfer", id));
    }
  
    get id(): string {
      let value = this.get("id");
      return value!.toString();
    }
  
    set id(value: string) {
      this.set("id", Value.fromString(value));
    }
  
    get emitter(): Bytes {
      let value = this.get("emitter");
      return value!.toBytes();
    }
  
    set emitter(value: Bytes) {
      this.set("emitter", Value.fromBytes(value));
    }
  
    get transaction(): string {
      let value = this.get("transaction");
      return value!.toString();
    }
  
    set transaction(value: string) {
      this.set("transaction", Value.fromString(value));
    }
  
    get timestamp(): BigInt {
      let value = this.get("timestamp");
      return value!.toBigInt();
    }
  
    set timestamp(value: BigInt) {
      this.set("timestamp", Value.fromBigInt(value));
    }
  
    get contract(): Bytes {
      let value = this.get("contract");
      return value!.toBytes();
    }
  
    set contract(value: Bytes) {
      this.set("contract", Value.fromBytes(value));
    }
  
    get from(): Bytes | null {
      let value = this.get("from");
      if (!value || value.kind == ValueKind.NULL) {
        return null;
      } else {
        return value.toBytes();
      }
    }
  
    set from(value: Bytes | null) {
      if (!value) {
        this.unset("from");
      } else {
        this.set("from", Value.fromBytes(<Bytes>value));
      }
    }
  
    get fromBalance(): string | null {
      let value = this.get("fromBalance");
      if (!value || value.kind == ValueKind.NULL) {
        return null;
      } else {
        return value.toString();
      }
    }
  
    set fromBalance(value: string | null) {
      if (!value) {
        this.unset("fromBalance");
      } else {
        this.set("fromBalance", Value.fromString(<string>value));
      }
    }
  
    get to(): Bytes | null {
      let value = this.get("to");
      if (!value || value.kind == ValueKind.NULL) {
        return null;
      } else {
        return value.toBytes();
      }
    }
  
    set to(value: Bytes | null) {
      if (!value) {
        this.unset("to");
      } else {
        this.set("to", Value.fromBytes(<Bytes>value));
      }
    }
  
    get toBalance(): string | null {
      let value = this.get("toBalance");
      if (!value || value.kind == ValueKind.NULL) {
        return null;
      } else {
        return value.toString();
      }
    }
  
    set toBalance(value: string | null) {
      if (!value) {
        this.unset("toBalance");
      } else {
        this.set("toBalance", Value.fromString(<string>value));
      }
    }
  
    get value(): BigDecimal {
      let value = this.get("value");
      return value!.toBigDecimal();
    }
  
    set value(value: BigDecimal) {
      this.set("value", Value.fromBigDecimal(value));
    }
  
    get valueExact(): BigInt {
      let value = this.get("valueExact");
      return value!.toBigInt();
    }
  
    set valueExact(value: BigInt) {
      this.set("valueExact", Value.fromBigInt(value));
    }
  }
  
  export class ERC721Contract extends Entity {
    constructor(id: Bytes) {
      super();
      this.set("id", Value.fromBytes(id));
    }
  
    save(): void {
      let id = this.get("id");
      assert(id != null, "Cannot save ERC721Contract entity without an ID");
      if (id) {
        assert(
          id.kind == ValueKind.BYTES,
          `Entities of type ERC721Contract must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
        );
        store.set("ERC721Contract", id.toBytes().toHexString(), this);
      }
    }
  
    static load(id: Bytes): ERC721Contract | null {
      return changetype<ERC721Contract | null>(
        store.get("ERC721Contract", id.toHexString())
      );
    }
  
    get id(): Bytes {
      let value = this.get("id");
      return value!.toBytes();
    }
  
    set id(value: Bytes) {
      this.set("id", Value.fromBytes(value));
    }
  
    get asAccount(): Bytes {
      let value = this.get("asAccount");
      return value!.toBytes();
    }
  
    set asAccount(value: Bytes) {
      this.set("asAccount", Value.fromBytes(value));
    }
  
    get supportsMetadata(): boolean {
      let value = this.get("supportsMetadata");
      return value!.toBoolean();
    }
  
    set supportsMetadata(value: boolean) {
      this.set("supportsMetadata", Value.fromBoolean(value));
    }
  
    get name(): string | null {
      let value = this.get("name");
      if (!value || value.kind == ValueKind.NULL) {
        return null;
      } else {
        return value.toString();
      }
    }
  
    set name(value: string | null) {
      if (!value) {
        this.unset("name");
      } else {
        this.set("name", Value.fromString(<string>value));
      }
    }
  
    get symbol(): string | null {
      let value = this.get("symbol");
      if (!value || value.kind == ValueKind.NULL) {
        return null;
      } else {
        return value.toString();
      }
    }
  
    set symbol(value: string | null) {
      if (!value) {
        this.unset("symbol");
      } else {
        this.set("symbol", Value.fromString(<string>value));
      }
    }
  
    get tokens(): Array<string> {
      let value = this.get("tokens");
      return value!.toStringArray();
    }
  
    set tokens(value: Array<string>) {
      this.set("tokens", Value.fromStringArray(value));
    }
  
    get operators(): Array<string> {
      let value = this.get("operators");
      return value!.toStringArray();
    }
  
    set operators(value: Array<string>) {
      this.set("operators", Value.fromStringArray(value));
    }
  
    get transfers(): Array<string> {
      let value = this.get("transfers");
      return value!.toStringArray();
    }
  
    set transfers(value: Array<string>) {
      this.set("transfers", Value.fromStringArray(value));
    }
  }
  
  export class ERC721Token extends Entity {
    constructor(id: string) {
      super();
      this.set("id", Value.fromString(id));
    }
  
    save(): void {
      let id = this.get("id");
      assert(id != null, "Cannot save ERC721Token entity without an ID");
      if (id) {
        assert(
          id.kind == ValueKind.STRING,
          `Entities of type ERC721Token must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
        );
        store.set("ERC721Token", id.toString(), this);
      }
    }
  
    static load(id: string): ERC721Token | null {
      return changetype<ERC721Token | null>(store.get("ERC721Token", id));
    }
  
    get id(): string {
      let value = this.get("id");
      return value!.toString();
    }
  
    set id(value: string) {
      this.set("id", Value.fromString(value));
    }
  
    get contract(): Bytes {
      let value = this.get("contract");
      return value!.toBytes();
    }
  
    set contract(value: Bytes) {
      this.set("contract", Value.fromBytes(value));
    }
  
    get identifier(): BigInt {
      let value = this.get("identifier");
      return value!.toBigInt();
    }
  
    set identifier(value: BigInt) {
      this.set("identifier", Value.fromBigInt(value));
    }
  
    get owner(): Bytes {
      let value = this.get("owner");
      return value!.toBytes();
    }
  
    set owner(value: Bytes) {
      this.set("owner", Value.fromBytes(value));
    }
  
    get approval(): Bytes {
      let value = this.get("approval");
      return value!.toBytes();
    }
  
    set approval(value: Bytes) {
      this.set("approval", Value.fromBytes(value));
    }
  
    get uri(): string | null {
      let value = this.get("uri");
      if (!value || value.kind == ValueKind.NULL) {
        return null;
      } else {
        return value.toString();
      }
    }
  
    set uri(value: string | null) {
      if (!value) {
        this.unset("uri");
      } else {
        this.set("uri", Value.fromString(<string>value));
      }
    }
  
    get transfers(): Array<string> {
      let value = this.get("transfers");
      return value!.toStringArray();
    }
  
    set transfers(value: Array<string>) {
      this.set("transfers", Value.fromStringArray(value));
    }
  }
  
  export class ERC721Operator extends Entity {
    constructor(id: string) {
      super();
      this.set("id", Value.fromString(id));
    }
  
    save(): void {
      let id = this.get("id");
      assert(id != null, "Cannot save ERC721Operator entity without an ID");
      if (id) {
        assert(
          id.kind == ValueKind.STRING,
          `Entities of type ERC721Operator must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
        );
        store.set("ERC721Operator", id.toString(), this);
      }
    }
  
    static load(id: string): ERC721Operator | null {
      return changetype<ERC721Operator | null>(store.get("ERC721Operator", id));
    }
  
    get id(): string {
      let value = this.get("id");
      return value!.toString();
    }
  
    set id(value: string) {
      this.set("id", Value.fromString(value));
    }
  
    get contract(): Bytes {
      let value = this.get("contract");
      return value!.toBytes();
    }
  
    set contract(value: Bytes) {
      this.set("contract", Value.fromBytes(value));
    }
  
    get owner(): Bytes {
      let value = this.get("owner");
      return value!.toBytes();
    }
  
    set owner(value: Bytes) {
      this.set("owner", Value.fromBytes(value));
    }
  
    get operator(): Bytes {
      let value = this.get("operator");
      return value!.toBytes();
    }
  
    set operator(value: Bytes) {
      this.set("operator", Value.fromBytes(value));
    }
  
    get approved(): boolean {
      let value = this.get("approved");
      return value!.toBoolean();
    }
  
    set approved(value: boolean) {
      this.set("approved", Value.fromBoolean(value));
    }
  }
  
  export class ERC721Transfer extends Entity {
    constructor(id: string) {
      super();
      this.set("id", Value.fromString(id));
    }
  
    save(): void {
      let id = this.get("id");
      assert(id != null, "Cannot save ERC721Transfer entity without an ID");
      if (id) {
        assert(
          id.kind == ValueKind.STRING,
          `Entities of type ERC721Transfer must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
        );
        store.set("ERC721Transfer", id.toString(), this);
      }
    }
  
    static load(id: string): ERC721Transfer | null {
      return changetype<ERC721Transfer | null>(store.get("ERC721Transfer", id));
    }
  
    get id(): string {
      let value = this.get("id");
      return value!.toString();
    }
  
    set id(value: string) {
      this.set("id", Value.fromString(value));
    }
  
    get emitter(): Bytes {
      let value = this.get("emitter");
      return value!.toBytes();
    }
  
    set emitter(value: Bytes) {
      this.set("emitter", Value.fromBytes(value));
    }
  
    get transaction(): string {
      let value = this.get("transaction");
      return value!.toString();
    }
  
    set transaction(value: string) {
      this.set("transaction", Value.fromString(value));
    }
  
    get timestamp(): BigInt {
      let value = this.get("timestamp");
      return value!.toBigInt();
    }
  
    set timestamp(value: BigInt) {
      this.set("timestamp", Value.fromBigInt(value));
    }
  
    get contract(): Bytes {
      let value = this.get("contract");
      return value!.toBytes();
    }
  
    set contract(value: Bytes) {
      this.set("contract", Value.fromBytes(value));
    }
  
    get token(): string {
      let value = this.get("token");
      return value!.toString();
    }
  
    set token(value: string) {
      this.set("token", Value.fromString(value));
    }
  
    get from(): Bytes {
      let value = this.get("from");
      return value!.toBytes();
    }
  
    set from(value: Bytes) {
      this.set("from", Value.fromBytes(value));
    }
  
    get to(): Bytes {
      let value = this.get("to");
      return value!.toBytes();
    }
  
    set to(value: Bytes) {
      this.set("to", Value.fromBytes(value));
    }
  }
  
  export class Governor extends Entity {
    constructor(id: Bytes) {
      super();
      this.set("id", Value.fromBytes(id));
    }
  
    save(): void {
      let id = this.get("id");
      assert(id != null, "Cannot save Governor entity without an ID");
      if (id) {
        assert(
          id.kind == ValueKind.BYTES,
          `Entities of type Governor must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
        );
        store.set("Governor", id.toBytes().toHexString(), this);
      }
    }
  
    static load(id: Bytes): Governor | null {
      return changetype<Governor | null>(store.get("Governor", id.toHexString()));
    }
  
    get id(): Bytes {
      let value = this.get("id");
      return value!.toBytes();
    }
  
    set id(value: Bytes) {
      this.set("id", Value.fromBytes(value));
    }
  
    get asAccount(): Bytes {
      let value = this.get("asAccount");
      return value!.toBytes();
    }
  
    set asAccount(value: Bytes) {
      this.set("asAccount", Value.fromBytes(value));
    }
  
    get mode(): string | null {
      let value = this.get("mode");
      if (!value || value.kind == ValueKind.NULL) {
        return null;
      } else {
        return value.toString();
      }
    }
  
    set mode(value: string | null) {
      if (!value) {
        this.unset("mode");
      } else {
        this.set("mode", Value.fromString(<string>value));
      }
    }
  
    get proposals(): Array<string> {
      let value = this.get("proposals");
      return value!.toStringArray();
    }
  
    set proposals(value: Array<string>) {
      this.set("proposals", Value.fromStringArray(value));
    }
  
    get proposalCreated(): Array<string> {
      let value = this.get("proposalCreated");
      return value!.toStringArray();
    }
  
    set proposalCreated(value: Array<string>) {
      this.set("proposalCreated", Value.fromStringArray(value));
    }
  
    get proposalQueued(): Array<string> {
      let value = this.get("proposalQueued");
      return value!.toStringArray();
    }
  
    set proposalQueued(value: Array<string>) {
      this.set("proposalQueued", Value.fromStringArray(value));
    }
  
    get proposalExecuted(): Array<string> {
      let value = this.get("proposalExecuted");
      return value!.toStringArray();
    }
  
    set proposalExecuted(value: Array<string>) {
      this.set("proposalExecuted", Value.fromStringArray(value));
    }
  
    get proposalCanceled(): Array<string> {
      let value = this.get("proposalCanceled");
      return value!.toStringArray();
    }
  
    set proposalCanceled(value: Array<string>) {
      this.set("proposalCanceled", Value.fromStringArray(value));
    }
  
    get votecast(): Array<string> {
      let value = this.get("votecast");
      return value!.toStringArray();
    }
  
    set votecast(value: Array<string>) {
      this.set("votecast", Value.fromStringArray(value));
    }
  }
  
  export class Proposal extends Entity {
    constructor(id: string) {
      super();
      this.set("id", Value.fromString(id));
    }
  
    save(): void {
      let id = this.get("id");
      assert(id != null, "Cannot save Proposal entity without an ID");
      if (id) {
        assert(
          id.kind == ValueKind.STRING,
          `Entities of type Proposal must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
        );
        store.set("Proposal", id.toString(), this);
      }
    }
  
    static load(id: string): Proposal | null {
      return changetype<Proposal | null>(store.get("Proposal", id));
    }
  
    get id(): string {
      let value = this.get("id");
      return value!.toString();
    }
  
    set id(value: string) {
      this.set("id", Value.fromString(value));
    }
  
    get governor(): Bytes {
      let value = this.get("governor");
      return value!.toBytes();
    }
  
    set governor(value: Bytes) {
      this.set("governor", Value.fromBytes(value));
    }
  
    get proposalId(): BigInt {
      let value = this.get("proposalId");
      return value!.toBigInt();
    }
  
    set proposalId(value: BigInt) {
      this.set("proposalId", Value.fromBigInt(value));
    }
  
    get proposer(): Bytes {
      let value = this.get("proposer");
      return value!.toBytes();
    }
  
    set proposer(value: Bytes) {
      this.set("proposer", Value.fromBytes(value));
    }
  
    get startBlock(): BigInt {
      let value = this.get("startBlock");
      return value!.toBigInt();
    }
  
    set startBlock(value: BigInt) {
      this.set("startBlock", Value.fromBigInt(value));
    }
  
    get endBlock(): BigInt {
      let value = this.get("endBlock");
      return value!.toBigInt();
    }
  
    set endBlock(value: BigInt) {
      this.set("endBlock", Value.fromBigInt(value));
    }
  
    get description(): string {
      let value = this.get("description");
      return value!.toString();
    }
  
    set description(value: string) {
      this.set("description", Value.fromString(value));
    }
  
    get eta(): BigInt | null {
      let value = this.get("eta");
      if (!value || value.kind == ValueKind.NULL) {
        return null;
      } else {
        return value.toBigInt();
      }
    }
  
    set eta(value: BigInt | null) {
      if (!value) {
        this.unset("eta");
      } else {
        this.set("eta", Value.fromBigInt(<BigInt>value));
      }
    }
  
    get canceled(): boolean {
      let value = this.get("canceled");
      return value!.toBoolean();
    }
  
    set canceled(value: boolean) {
      this.set("canceled", Value.fromBoolean(value));
    }
  
    get queued(): boolean {
      let value = this.get("queued");
      return value!.toBoolean();
    }
  
    set queued(value: boolean) {
      this.set("queued", Value.fromBoolean(value));
    }
  
    get executed(): boolean {
      let value = this.get("executed");
      return value!.toBoolean();
    }
  
    set executed(value: boolean) {
      this.set("executed", Value.fromBoolean(value));
    }
  
    get calls(): Array<string> {
      let value = this.get("calls");
      return value!.toStringArray();
    }
  
    set calls(value: Array<string>) {
      this.set("calls", Value.fromStringArray(value));
    }
  
    get supports(): Array<string> {
      let value = this.get("supports");
      return value!.toStringArray();
    }
  
    set supports(value: Array<string>) {
      this.set("supports", Value.fromStringArray(value));
    }
  
    get receipts(): Array<string> {
      let value = this.get("receipts");
      return value!.toStringArray();
    }
  
    set receipts(value: Array<string>) {
      this.set("receipts", Value.fromStringArray(value));
    }
  
    get proposalCreated(): Array<string> {
      let value = this.get("proposalCreated");
      return value!.toStringArray();
    }
  
    set proposalCreated(value: Array<string>) {
      this.set("proposalCreated", Value.fromStringArray(value));
    }
  
    get proposalQueued(): Array<string> {
      let value = this.get("proposalQueued");
      return value!.toStringArray();
    }
  
    set proposalQueued(value: Array<string>) {
      this.set("proposalQueued", Value.fromStringArray(value));
    }
  
    get proposalExecuted(): Array<string> {
      let value = this.get("proposalExecuted");
      return value!.toStringArray();
    }
  
    set proposalExecuted(value: Array<string>) {
      this.set("proposalExecuted", Value.fromStringArray(value));
    }
  
    get proposalCanceled(): Array<string> {
      let value = this.get("proposalCanceled");
      return value!.toStringArray();
    }
  
    set proposalCanceled(value: Array<string>) {
      this.set("proposalCanceled", Value.fromStringArray(value));
    }
  
    get votecast(): Array<string> {
      let value = this.get("votecast");
      return value!.toStringArray();
    }
  
    set votecast(value: Array<string>) {
      this.set("votecast", Value.fromStringArray(value));
    }
  }
  
  export class ProposalCall extends Entity {
    constructor(id: string) {
      super();
      this.set("id", Value.fromString(id));
    }
  
    save(): void {
      let id = this.get("id");
      assert(id != null, "Cannot save ProposalCall entity without an ID");
      if (id) {
        assert(
          id.kind == ValueKind.STRING,
          `Entities of type ProposalCall must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
        );
        store.set("ProposalCall", id.toString(), this);
      }
    }
  
    static load(id: string): ProposalCall | null {
      return changetype<ProposalCall | null>(store.get("ProposalCall", id));
    }
  
    get id(): string {
      let value = this.get("id");
      return value!.toString();
    }
  
    set id(value: string) {
      this.set("id", Value.fromString(value));
    }
  
    get proposal(): string {
      let value = this.get("proposal");
      return value!.toString();
    }
  
    set proposal(value: string) {
      this.set("proposal", Value.fromString(value));
    }
  
    get index(): i32 {
      let value = this.get("index");
      return value!.toI32();
    }
  
    set index(value: i32) {
      this.set("index", Value.fromI32(value));
    }
  
    get target(): Bytes {
      let value = this.get("target");
      return value!.toBytes();
    }
  
    set target(value: Bytes) {
      this.set("target", Value.fromBytes(value));
    }
  
    get value(): BigDecimal {
      let value = this.get("value");
      return value!.toBigDecimal();
    }
  
    set value(value: BigDecimal) {
      this.set("value", Value.fromBigDecimal(value));
    }
  
    get signature(): string {
      let value = this.get("signature");
      return value!.toString();
    }
  
    set signature(value: string) {
      this.set("signature", Value.fromString(value));
    }
  
    get calldata(): Bytes {
      let value = this.get("calldata");
      return value!.toBytes();
    }
  
    set calldata(value: Bytes) {
      this.set("calldata", Value.fromBytes(value));
    }
  }
  
  export class ProposalSupport extends Entity {
    constructor(id: string) {
      super();
      this.set("id", Value.fromString(id));
    }
  
    save(): void {
      let id = this.get("id");
      assert(id != null, "Cannot save ProposalSupport entity without an ID");
      if (id) {
        assert(
          id.kind == ValueKind.STRING,
          `Entities of type ProposalSupport must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
        );
        store.set("ProposalSupport", id.toString(), this);
      }
    }
  
    static load(id: string): ProposalSupport | null {
      return changetype<ProposalSupport | null>(store.get("ProposalSupport", id));
    }
  
    get id(): string {
      let value = this.get("id");
      return value!.toString();
    }
  
    set id(value: string) {
      this.set("id", Value.fromString(value));
    }
  
    get proposal(): string {
      let value = this.get("proposal");
      return value!.toString();
    }
  
    set proposal(value: string) {
      this.set("proposal", Value.fromString(value));
    }
  
    get support(): i32 {
      let value = this.get("support");
      return value!.toI32();
    }
  
    set support(value: i32) {
      this.set("support", Value.fromI32(value));
    }
  
    get votes(): Array<string> {
      let value = this.get("votes");
      return value!.toStringArray();
    }
  
    set votes(value: Array<string>) {
      this.set("votes", Value.fromStringArray(value));
    }
  }
  
  export class VoteReceipt extends Entity {
    constructor(id: string) {
      super();
      this.set("id", Value.fromString(id));
    }
  
    save(): void {
      let id = this.get("id");
      assert(id != null, "Cannot save VoteReceipt entity without an ID");
      if (id) {
        assert(
          id.kind == ValueKind.STRING,
          `Entities of type VoteReceipt must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
        );
        store.set("VoteReceipt", id.toString(), this);
      }
    }
  
    static load(id: string): VoteReceipt | null {
      return changetype<VoteReceipt | null>(store.get("VoteReceipt", id));
    }
  
    get id(): string {
      let value = this.get("id");
      return value!.toString();
    }
  
    set id(value: string) {
      this.set("id", Value.fromString(value));
    }
  
    get proposal(): string {
      let value = this.get("proposal");
      return value!.toString();
    }
  
    set proposal(value: string) {
      this.set("proposal", Value.fromString(value));
    }
  
    get voter(): Bytes {
      let value = this.get("voter");
      return value!.toBytes();
    }
  
    set voter(value: Bytes) {
      this.set("voter", Value.fromBytes(value));
    }
  
    get support(): string {
      let value = this.get("support");
      return value!.toString();
    }
  
    set support(value: string) {
      this.set("support", Value.fromString(value));
    }
  
    get weight(): BigInt {
      let value = this.get("weight");
      return value!.toBigInt();
    }
  
    set weight(value: BigInt) {
      this.set("weight", Value.fromBigInt(value));
    }
  
    get reason(): string {
      let value = this.get("reason");
      return value!.toString();
    }
  
    set reason(value: string) {
      this.set("reason", Value.fromString(value));
    }
  }
  
  export class ProposalCreated extends Entity {
    constructor(id: string) {
      super();
      this.set("id", Value.fromString(id));
    }
  
    save(): void {
      let id = this.get("id");
      assert(id != null, "Cannot save ProposalCreated entity without an ID");
      if (id) {
        assert(
          id.kind == ValueKind.STRING,
          `Entities of type ProposalCreated must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
        );
        store.set("ProposalCreated", id.toString(), this);
      }
    }
  
    static load(id: string): ProposalCreated | null {
      return changetype<ProposalCreated | null>(store.get("ProposalCreated", id));
    }
  
    get id(): string {
      let value = this.get("id");
      return value!.toString();
    }
  
    set id(value: string) {
      this.set("id", Value.fromString(value));
    }
  
    get emitter(): Bytes {
      let value = this.get("emitter");
      return value!.toBytes();
    }
  
    set emitter(value: Bytes) {
      this.set("emitter", Value.fromBytes(value));
    }
  
    get transaction(): string {
      let value = this.get("transaction");
      return value!.toString();
    }
  
    set transaction(value: string) {
      this.set("transaction", Value.fromString(value));
    }
  
    get timestamp(): BigInt {
      let value = this.get("timestamp");
      return value!.toBigInt();
    }
  
    set timestamp(value: BigInt) {
      this.set("timestamp", Value.fromBigInt(value));
    }
  
    get governor(): Bytes {
      let value = this.get("governor");
      return value!.toBytes();
    }
  
    set governor(value: Bytes) {
      this.set("governor", Value.fromBytes(value));
    }
  
    get proposal(): string {
      let value = this.get("proposal");
      return value!.toString();
    }
  
    set proposal(value: string) {
      this.set("proposal", Value.fromString(value));
    }
  
    get proposer(): Bytes {
      let value = this.get("proposer");
      return value!.toBytes();
    }
  
    set proposer(value: Bytes) {
      this.set("proposer", Value.fromBytes(value));
    }
  }
  
  export class ProposalQueued extends Entity {
    constructor(id: string) {
      super();
      this.set("id", Value.fromString(id));
    }
  
    save(): void {
      let id = this.get("id");
      assert(id != null, "Cannot save ProposalQueued entity without an ID");
      if (id) {
        assert(
          id.kind == ValueKind.STRING,
          `Entities of type ProposalQueued must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
        );
        store.set("ProposalQueued", id.toString(), this);
      }
    }
  
    static load(id: string): ProposalQueued | null {
      return changetype<ProposalQueued | null>(store.get("ProposalQueued", id));
    }
  
    get id(): string {
      let value = this.get("id");
      return value!.toString();
    }
  
    set id(value: string) {
      this.set("id", Value.fromString(value));
    }
  
    get emitter(): Bytes {
      let value = this.get("emitter");
      return value!.toBytes();
    }
  
    set emitter(value: Bytes) {
      this.set("emitter", Value.fromBytes(value));
    }
  
    get transaction(): string {
      let value = this.get("transaction");
      return value!.toString();
    }
  
    set transaction(value: string) {
      this.set("transaction", Value.fromString(value));
    }
  
    get timestamp(): BigInt {
      let value = this.get("timestamp");
      return value!.toBigInt();
    }
  
    set timestamp(value: BigInt) {
      this.set("timestamp", Value.fromBigInt(value));
    }
  
    get governor(): Bytes {
      let value = this.get("governor");
      return value!.toBytes();
    }
  
    set governor(value: Bytes) {
      this.set("governor", Value.fromBytes(value));
    }
  
    get proposal(): string {
      let value = this.get("proposal");
      return value!.toString();
    }
  
    set proposal(value: string) {
      this.set("proposal", Value.fromString(value));
    }
  
    get eta(): BigInt {
      let value = this.get("eta");
      return value!.toBigInt();
    }
  
    set eta(value: BigInt) {
      this.set("eta", Value.fromBigInt(value));
    }
  }
  
  export class ProposalExecuted extends Entity {
    constructor(id: string) {
      super();
      this.set("id", Value.fromString(id));
    }
  
    save(): void {
      let id = this.get("id");
      assert(id != null, "Cannot save ProposalExecuted entity without an ID");
      if (id) {
        assert(
          id.kind == ValueKind.STRING,
          `Entities of type ProposalExecuted must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
        );
        store.set("ProposalExecuted", id.toString(), this);
      }
    }
  
    static load(id: string): ProposalExecuted | null {
      return changetype<ProposalExecuted | null>(
        store.get("ProposalExecuted", id)
      );
    }
  
    get id(): string {
      let value = this.get("id");
      return value!.toString();
    }
  
    set id(value: string) {
      this.set("id", Value.fromString(value));
    }
  
    get emitter(): Bytes {
      let value = this.get("emitter");
      return value!.toBytes();
    }
  
    set emitter(value: Bytes) {
      this.set("emitter", Value.fromBytes(value));
    }
  
    get transaction(): string {
      let value = this.get("transaction");
      return value!.toString();
    }
  
    set transaction(value: string) {
      this.set("transaction", Value.fromString(value));
    }
  
    get timestamp(): BigInt {
      let value = this.get("timestamp");
      return value!.toBigInt();
    }
  
    set timestamp(value: BigInt) {
      this.set("timestamp", Value.fromBigInt(value));
    }
  
    get governor(): Bytes {
      let value = this.get("governor");
      return value!.toBytes();
    }
  
    set governor(value: Bytes) {
      this.set("governor", Value.fromBytes(value));
    }
  
    get proposal(): string {
      let value = this.get("proposal");
      return value!.toString();
    }
  
    set proposal(value: string) {
      this.set("proposal", Value.fromString(value));
    }
  }
  
  export class ProposalCanceled extends Entity {
    constructor(id: string) {
      super();
      this.set("id", Value.fromString(id));
    }
  
    save(): void {
      let id = this.get("id");
      assert(id != null, "Cannot save ProposalCanceled entity without an ID");
      if (id) {
        assert(
          id.kind == ValueKind.STRING,
          `Entities of type ProposalCanceled must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
        );
        store.set("ProposalCanceled", id.toString(), this);
      }
    }
  
    static load(id: string): ProposalCanceled | null {
      return changetype<ProposalCanceled | null>(
        store.get("ProposalCanceled", id)
      );
    }
  
    get id(): string {
      let value = this.get("id");
      return value!.toString();
    }
  
    set id(value: string) {
      this.set("id", Value.fromString(value));
    }
  
    get emitter(): Bytes {
      let value = this.get("emitter");
      return value!.toBytes();
    }
  
    set emitter(value: Bytes) {
      this.set("emitter", Value.fromBytes(value));
    }
  
    get transaction(): string {
      let value = this.get("transaction");
      return value!.toString();
    }
  
    set transaction(value: string) {
      this.set("transaction", Value.fromString(value));
    }
  
    get timestamp(): BigInt {
      let value = this.get("timestamp");
      return value!.toBigInt();
    }
  
    set timestamp(value: BigInt) {
      this.set("timestamp", Value.fromBigInt(value));
    }
  
    get governor(): Bytes {
      let value = this.get("governor");
      return value!.toBytes();
    }
  
    set governor(value: Bytes) {
      this.set("governor", Value.fromBytes(value));
    }
  
    get proposal(): string {
      let value = this.get("proposal");
      return value!.toString();
    }
  
    set proposal(value: string) {
      this.set("proposal", Value.fromString(value));
    }
  }
  
  export class VoteCast extends Entity {
    constructor(id: string) {
      super();
      this.set("id", Value.fromString(id));
    }
  
    save(): void {
      let id = this.get("id");
      assert(id != null, "Cannot save VoteCast entity without an ID");
      if (id) {
        assert(
          id.kind == ValueKind.STRING,
          `Entities of type VoteCast must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
        );
        store.set("VoteCast", id.toString(), this);
      }
    }
  
    static load(id: string): VoteCast | null {
      return changetype<VoteCast | null>(store.get("VoteCast", id));
    }
  
    get id(): string {
      let value = this.get("id");
      return value!.toString();
    }
  
    set id(value: string) {
      this.set("id", Value.fromString(value));
    }
  
    get emitter(): Bytes {
      let value = this.get("emitter");
      return value!.toBytes();
    }
  
    set emitter(value: Bytes) {
      this.set("emitter", Value.fromBytes(value));
    }
  
    get transaction(): string {
      let value = this.get("transaction");
      return value!.toString();
    }
  
    set transaction(value: string) {
      this.set("transaction", Value.fromString(value));
    }
  
    get timestamp(): BigInt {
      let value = this.get("timestamp");
      return value!.toBigInt();
    }
  
    set timestamp(value: BigInt) {
      this.set("timestamp", Value.fromBigInt(value));
    }
  
    get governor(): Bytes {
      let value = this.get("governor");
      return value!.toBytes();
    }
  
    set governor(value: Bytes) {
      this.set("governor", Value.fromBytes(value));
    }
  
    get proposal(): string {
      let value = this.get("proposal");
      return value!.toString();
    }
  
    set proposal(value: string) {
      this.set("proposal", Value.fromString(value));
    }
  
    get support(): string {
      let value = this.get("support");
      return value!.toString();
    }
  
    set support(value: string) {
      this.set("support", Value.fromString(value));
    }
  
    get receipt(): string {
      let value = this.get("receipt");
      return value!.toString();
    }
  
    set receipt(value: string) {
      this.set("receipt", Value.fromString(value));
    }
  
    get voter(): Bytes {
      let value = this.get("voter");
      return value!.toBytes();
    }
  
    set voter(value: Bytes) {
      this.set("voter", Value.fromBytes(value));
    }
  }
  
  export class Ownable extends Entity {
    constructor(id: Bytes) {
      super();
      this.set("id", Value.fromBytes(id));
    }
  
    save(): void {
      let id = this.get("id");
      assert(id != null, "Cannot save Ownable entity without an ID");
      if (id) {
        assert(
          id.kind == ValueKind.BYTES,
          `Entities of type Ownable must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
        );
        store.set("Ownable", id.toBytes().toHexString(), this);
      }
    }
  
    static load(id: Bytes): Ownable | null {
      return changetype<Ownable | null>(store.get("Ownable", id.toHexString()));
    }
  
    get id(): Bytes {
      let value = this.get("id");
      return value!.toBytes();
    }
  
    set id(value: Bytes) {
      this.set("id", Value.fromBytes(value));
    }
  
    get asAccount(): Bytes {
      let value = this.get("asAccount");
      return value!.toBytes();
    }
  
    set asAccount(value: Bytes) {
      this.set("asAccount", Value.fromBytes(value));
    }
  
    get owner(): Bytes {
      let value = this.get("owner");
      return value!.toBytes();
    }
  
    set owner(value: Bytes) {
      this.set("owner", Value.fromBytes(value));
    }
  
    get ownershipTransferred(): Array<string> {
      let value = this.get("ownershipTransferred");
      return value!.toStringArray();
    }
  
    set ownershipTransferred(value: Array<string>) {
      this.set("ownershipTransferred", Value.fromStringArray(value));
    }
  }
  
  export class OwnershipTransferred extends Entity {
    constructor(id: string) {
      super();
      this.set("id", Value.fromString(id));
    }
  
    save(): void {
      let id = this.get("id");
      assert(id != null, "Cannot save OwnershipTransferred entity without an ID");
      if (id) {
        assert(
          id.kind == ValueKind.STRING,
          `Entities of type OwnershipTransferred must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
        );
        store.set("OwnershipTransferred", id.toString(), this);
      }
    }
  
    static load(id: string): OwnershipTransferred | null {
      return changetype<OwnershipTransferred | null>(
        store.get("OwnershipTransferred", id)
      );
    }
  
    get id(): string {
      let value = this.get("id");
      return value!.toString();
    }
  
    set id(value: string) {
      this.set("id", Value.fromString(value));
    }
  
    get emitter(): Bytes {
      let value = this.get("emitter");
      return value!.toBytes();
    }
  
    set emitter(value: Bytes) {
      this.set("emitter", Value.fromBytes(value));
    }
  
    get transaction(): string {
      let value = this.get("transaction");
      return value!.toString();
    }
  
    set transaction(value: string) {
      this.set("transaction", Value.fromString(value));
    }
  
    get timestamp(): BigInt {
      let value = this.get("timestamp");
      return value!.toBigInt();
    }
  
    set timestamp(value: BigInt) {
      this.set("timestamp", Value.fromBigInt(value));
    }
  
    get contract(): Bytes {
      let value = this.get("contract");
      return value!.toBytes();
    }
  
    set contract(value: Bytes) {
      this.set("contract", Value.fromBytes(value));
    }
  
    get owner(): Bytes {
      let value = this.get("owner");
      return value!.toBytes();
    }
  
    set owner(value: Bytes) {
      this.set("owner", Value.fromBytes(value));
    }
  }
  
  export class Pausable extends Entity {
    constructor(id: Bytes) {
      super();
      this.set("id", Value.fromBytes(id));
    }
  
    save(): void {
      let id = this.get("id");
      assert(id != null, "Cannot save Pausable entity without an ID");
      if (id) {
        assert(
          id.kind == ValueKind.BYTES,
          `Entities of type Pausable must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
        );
        store.set("Pausable", id.toBytes().toHexString(), this);
      }
    }
  
    static load(id: Bytes): Pausable | null {
      return changetype<Pausable | null>(store.get("Pausable", id.toHexString()));
    }
  
    get id(): Bytes {
      let value = this.get("id");
      return value!.toBytes();
    }
  
    set id(value: Bytes) {
      this.set("id", Value.fromBytes(value));
    }
  
    get asAccount(): Bytes {
      let value = this.get("asAccount");
      return value!.toBytes();
    }
  
    set asAccount(value: Bytes) {
      this.set("asAccount", Value.fromBytes(value));
    }
  
    get isPaused(): boolean {
      let value = this.get("isPaused");
      return value!.toBoolean();
    }
  
    set isPaused(value: boolean) {
      this.set("isPaused", Value.fromBoolean(value));
    }
  
    get paused(): Array<string> {
      let value = this.get("paused");
      return value!.toStringArray();
    }
  
    set paused(value: Array<string>) {
      this.set("paused", Value.fromStringArray(value));
    }
  }
  
  export class Paused extends Entity {
    constructor(id: string) {
      super();
      this.set("id", Value.fromString(id));
    }
  
    save(): void {
      let id = this.get("id");
      assert(id != null, "Cannot save Paused entity without an ID");
      if (id) {
        assert(
          id.kind == ValueKind.STRING,
          `Entities of type Paused must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
        );
        store.set("Paused", id.toString(), this);
      }
    }
  
    static load(id: string): Paused | null {
      return changetype<Paused | null>(store.get("Paused", id));
    }
  
    get id(): string {
      let value = this.get("id");
      return value!.toString();
    }
  
    set id(value: string) {
      this.set("id", Value.fromString(value));
    }
  
    get emitter(): Bytes {
      let value = this.get("emitter");
      return value!.toBytes();
    }
  
    set emitter(value: Bytes) {
      this.set("emitter", Value.fromBytes(value));
    }
  
    get transaction(): string {
      let value = this.get("transaction");
      return value!.toString();
    }
  
    set transaction(value: string) {
      this.set("transaction", Value.fromString(value));
    }
  
    get timestamp(): BigInt {
      let value = this.get("timestamp");
      return value!.toBigInt();
    }
  
    set timestamp(value: BigInt) {
      this.set("timestamp", Value.fromBigInt(value));
    }
  
    get contract(): Bytes {
      let value = this.get("contract");
      return value!.toBytes();
    }
  
    set contract(value: Bytes) {
      this.set("contract", Value.fromBytes(value));
    }
  
    get isPaused(): boolean {
      let value = this.get("isPaused");
      return value!.toBoolean();
    }
  
    set isPaused(value: boolean) {
      this.set("isPaused", Value.fromBoolean(value));
    }
  }
  
  export class Timelock extends Entity {
    constructor(id: Bytes) {
      super();
      this.set("id", Value.fromBytes(id));
    }
  
    save(): void {
      let id = this.get("id");
      assert(id != null, "Cannot save Timelock entity without an ID");
      if (id) {
        assert(
          id.kind == ValueKind.BYTES,
          `Entities of type Timelock must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
        );
        store.set("Timelock", id.toBytes().toHexString(), this);
      }
    }
  
    static load(id: Bytes): Timelock | null {
      return changetype<Timelock | null>(store.get("Timelock", id.toHexString()));
    }
  
    get id(): Bytes {
      let value = this.get("id");
      return value!.toBytes();
    }
  
    set id(value: Bytes) {
      this.set("id", Value.fromBytes(value));
    }
  
    get asAccount(): Bytes {
      let value = this.get("asAccount");
      return value!.toBytes();
    }
  
    set asAccount(value: Bytes) {
      this.set("asAccount", Value.fromBytes(value));
    }
  
    get operations(): Array<string> {
      let value = this.get("operations");
      return value!.toStringArray();
    }
  
    set operations(value: Array<string>) {
      this.set("operations", Value.fromStringArray(value));
    }
  
    get scheduled(): Array<string> {
      let value = this.get("scheduled");
      return value!.toStringArray();
    }
  
    set scheduled(value: Array<string>) {
      this.set("scheduled", Value.fromStringArray(value));
    }
  
    get executed(): Array<string> {
      let value = this.get("executed");
      return value!.toStringArray();
    }
  
    set executed(value: Array<string>) {
      this.set("executed", Value.fromStringArray(value));
    }
  
    get cancelled(): Array<string> {
      let value = this.get("cancelled");
      return value!.toStringArray();
    }
  
    set cancelled(value: Array<string>) {
      this.set("cancelled", Value.fromStringArray(value));
    }
  
    get mindelaychange(): Array<string> {
      let value = this.get("mindelaychange");
      return value!.toStringArray();
    }
  
    set mindelaychange(value: Array<string>) {
      this.set("mindelaychange", Value.fromStringArray(value));
    }
  }
  
  export class TimelockOperation extends Entity {
    constructor(id: string) {
      super();
      this.set("id", Value.fromString(id));
    }
  
    save(): void {
      let id = this.get("id");
      assert(id != null, "Cannot save TimelockOperation entity without an ID");
      if (id) {
        assert(
          id.kind == ValueKind.STRING,
          `Entities of type TimelockOperation must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
        );
        store.set("TimelockOperation", id.toString(), this);
      }
    }
  
    static load(id: string): TimelockOperation | null {
      return changetype<TimelockOperation | null>(
        store.get("TimelockOperation", id)
      );
    }
  
    get id(): string {
      let value = this.get("id");
      return value!.toString();
    }
  
    set id(value: string) {
      this.set("id", Value.fromString(value));
    }
  
    get contract(): Bytes {
      let value = this.get("contract");
      return value!.toBytes();
    }
  
    set contract(value: Bytes) {
      this.set("contract", Value.fromBytes(value));
    }
  
    get status(): string {
      let value = this.get("status");
      return value!.toString();
    }
  
    set status(value: string) {
      this.set("status", Value.fromString(value));
    }
  
    get delay(): BigInt {
      let value = this.get("delay");
      return value!.toBigInt();
    }
  
    set delay(value: BigInt) {
      this.set("delay", Value.fromBigInt(value));
    }
  
    get timestamp(): BigInt {
      let value = this.get("timestamp");
      return value!.toBigInt();
    }
  
    set timestamp(value: BigInt) {
      this.set("timestamp", Value.fromBigInt(value));
    }
  
    get predecessor(): string | null {
      let value = this.get("predecessor");
      if (!value || value.kind == ValueKind.NULL) {
        return null;
      } else {
        return value.toString();
      }
    }
  
    set predecessor(value: string | null) {
      if (!value) {
        this.unset("predecessor");
      } else {
        this.set("predecessor", Value.fromString(<string>value));
      }
    }
  
    get calls(): Array<string> {
      let value = this.get("calls");
      return value!.toStringArray();
    }
  
    set calls(value: Array<string>) {
      this.set("calls", Value.fromStringArray(value));
    }
  
    get scheduled(): Array<string> {
      let value = this.get("scheduled");
      return value!.toStringArray();
    }
  
    set scheduled(value: Array<string>) {
      this.set("scheduled", Value.fromStringArray(value));
    }
  
    get executed(): Array<string> {
      let value = this.get("executed");
      return value!.toStringArray();
    }
  
    set executed(value: Array<string>) {
      this.set("executed", Value.fromStringArray(value));
    }
  
    get cancelled(): Array<string> {
      let value = this.get("cancelled");
      return value!.toStringArray();
    }
  
    set cancelled(value: Array<string>) {
      this.set("cancelled", Value.fromStringArray(value));
    }
  }
  
  export class TimelockCall extends Entity {
    constructor(id: string) {
      super();
      this.set("id", Value.fromString(id));
    }
  
    save(): void {
      let id = this.get("id");
      assert(id != null, "Cannot save TimelockCall entity without an ID");
      if (id) {
        assert(
          id.kind == ValueKind.STRING,
          `Entities of type TimelockCall must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
        );
        store.set("TimelockCall", id.toString(), this);
      }
    }
  
    static load(id: string): TimelockCall | null {
      return changetype<TimelockCall | null>(store.get("TimelockCall", id));
    }
  
    get id(): string {
      let value = this.get("id");
      return value!.toString();
    }
  
    set id(value: string) {
      this.set("id", Value.fromString(value));
    }
  
    get operation(): string {
      let value = this.get("operation");
      return value!.toString();
    }
  
    set operation(value: string) {
      this.set("operation", Value.fromString(value));
    }
  
    get index(): BigInt {
      let value = this.get("index");
      return value!.toBigInt();
    }
  
    set index(value: BigInt) {
      this.set("index", Value.fromBigInt(value));
    }
  
    get target(): Bytes {
      let value = this.get("target");
      return value!.toBytes();
    }
  
    set target(value: Bytes) {
      this.set("target", Value.fromBytes(value));
    }
  
    get value(): BigDecimal {
      let value = this.get("value");
      return value!.toBigDecimal();
    }
  
    set value(value: BigDecimal) {
      this.set("value", Value.fromBigDecimal(value));
    }
  
    get data(): Bytes {
      let value = this.get("data");
      return value!.toBytes();
    }
  
    set data(value: Bytes) {
      this.set("data", Value.fromBytes(value));
    }
  
    get scheduled(): Array<string> {
      let value = this.get("scheduled");
      return value!.toStringArray();
    }
  
    set scheduled(value: Array<string>) {
      this.set("scheduled", Value.fromStringArray(value));
    }
  
    get executed(): Array<string> {
      let value = this.get("executed");
      return value!.toStringArray();
    }
  
    set executed(value: Array<string>) {
      this.set("executed", Value.fromStringArray(value));
    }
  }
  
  export class TimelockOperationScheduled extends Entity {
    constructor(id: string) {
      super();
      this.set("id", Value.fromString(id));
    }
  
    save(): void {
      let id = this.get("id");
      assert(
        id != null,
        "Cannot save TimelockOperationScheduled entity without an ID"
      );
      if (id) {
        assert(
          id.kind == ValueKind.STRING,
          `Entities of type TimelockOperationScheduled must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
        );
        store.set("TimelockOperationScheduled", id.toString(), this);
      }
    }
  
    static load(id: string): TimelockOperationScheduled | null {
      return changetype<TimelockOperationScheduled | null>(
        store.get("TimelockOperationScheduled", id)
      );
    }
  
    get id(): string {
      let value = this.get("id");
      return value!.toString();
    }
  
    set id(value: string) {
      this.set("id", Value.fromString(value));
    }
  
    get emitter(): Bytes {
      let value = this.get("emitter");
      return value!.toBytes();
    }
  
    set emitter(value: Bytes) {
      this.set("emitter", Value.fromBytes(value));
    }
  
    get transaction(): string {
      let value = this.get("transaction");
      return value!.toString();
    }
  
    set transaction(value: string) {
      this.set("transaction", Value.fromString(value));
    }
  
    get timestamp(): BigInt {
      let value = this.get("timestamp");
      return value!.toBigInt();
    }
  
    set timestamp(value: BigInt) {
      this.set("timestamp", Value.fromBigInt(value));
    }
  
    get contract(): Bytes {
      let value = this.get("contract");
      return value!.toBytes();
    }
  
    set contract(value: Bytes) {
      this.set("contract", Value.fromBytes(value));
    }
  
    get operation(): string {
      let value = this.get("operation");
      return value!.toString();
    }
  
    set operation(value: string) {
      this.set("operation", Value.fromString(value));
    }
  
    get call(): string {
      let value = this.get("call");
      return value!.toString();
    }
  
    set call(value: string) {
      this.set("call", Value.fromString(value));
    }
  }
  
  export class TimelockOperationExecuted extends Entity {
    constructor(id: string) {
      super();
      this.set("id", Value.fromString(id));
    }
  
    save(): void {
      let id = this.get("id");
      assert(
        id != null,
        "Cannot save TimelockOperationExecuted entity without an ID"
      );
      if (id) {
        assert(
          id.kind == ValueKind.STRING,
          `Entities of type TimelockOperationExecuted must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
        );
        store.set("TimelockOperationExecuted", id.toString(), this);
      }
    }
  
    static load(id: string): TimelockOperationExecuted | null {
      return changetype<TimelockOperationExecuted | null>(
        store.get("TimelockOperationExecuted", id)
      );
    }
  
    get id(): string {
      let value = this.get("id");
      return value!.toString();
    }
  
    set id(value: string) {
      this.set("id", Value.fromString(value));
    }
  
    get emitter(): Bytes {
      let value = this.get("emitter");
      return value!.toBytes();
    }
  
    set emitter(value: Bytes) {
      this.set("emitter", Value.fromBytes(value));
    }
  
    get transaction(): string {
      let value = this.get("transaction");
      return value!.toString();
    }
  
    set transaction(value: string) {
      this.set("transaction", Value.fromString(value));
    }
  
    get timestamp(): BigInt {
      let value = this.get("timestamp");
      return value!.toBigInt();
    }
  
    set timestamp(value: BigInt) {
      this.set("timestamp", Value.fromBigInt(value));
    }
  
    get contract(): Bytes {
      let value = this.get("contract");
      return value!.toBytes();
    }
  
    set contract(value: Bytes) {
      this.set("contract", Value.fromBytes(value));
    }
  
    get operation(): string {
      let value = this.get("operation");
      return value!.toString();
    }
  
    set operation(value: string) {
      this.set("operation", Value.fromString(value));
    }
  
    get call(): string {
      let value = this.get("call");
      return value!.toString();
    }
  
    set call(value: string) {
      this.set("call", Value.fromString(value));
    }
  }
  
  export class TimelockOperationCancelled extends Entity {
    constructor(id: string) {
      super();
      this.set("id", Value.fromString(id));
    }
  
    save(): void {
      let id = this.get("id");
      assert(
        id != null,
        "Cannot save TimelockOperationCancelled entity without an ID"
      );
      if (id) {
        assert(
          id.kind == ValueKind.STRING,
          `Entities of type TimelockOperationCancelled must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
        );
        store.set("TimelockOperationCancelled", id.toString(), this);
      }
    }
  
    static load(id: string): TimelockOperationCancelled | null {
      return changetype<TimelockOperationCancelled | null>(
        store.get("TimelockOperationCancelled", id)
      );
    }
  
    get id(): string {
      let value = this.get("id");
      return value!.toString();
    }
  
    set id(value: string) {
      this.set("id", Value.fromString(value));
    }
  
    get emitter(): Bytes {
      let value = this.get("emitter");
      return value!.toBytes();
    }
  
    set emitter(value: Bytes) {
      this.set("emitter", Value.fromBytes(value));
    }
  
    get transaction(): string {
      let value = this.get("transaction");
      return value!.toString();
    }
  
    set transaction(value: string) {
      this.set("transaction", Value.fromString(value));
    }
  
    get timestamp(): BigInt {
      let value = this.get("timestamp");
      return value!.toBigInt();
    }
  
    set timestamp(value: BigInt) {
      this.set("timestamp", Value.fromBigInt(value));
    }
  
    get contract(): Bytes {
      let value = this.get("contract");
      return value!.toBytes();
    }
  
    set contract(value: Bytes) {
      this.set("contract", Value.fromBytes(value));
    }
  
    get operation(): string {
      let value = this.get("operation");
      return value!.toString();
    }
  
    set operation(value: string) {
      this.set("operation", Value.fromString(value));
    }
  }
  
  export class TimelockMinDelayChange extends Entity {
    constructor(id: string) {
      super();
      this.set("id", Value.fromString(id));
    }
  
    save(): void {
      let id = this.get("id");
      assert(
        id != null,
        "Cannot save TimelockMinDelayChange entity without an ID"
      );
      if (id) {
        assert(
          id.kind == ValueKind.STRING,
          `Entities of type TimelockMinDelayChange must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
        );
        store.set("TimelockMinDelayChange", id.toString(), this);
      }
    }
  
    static load(id: string): TimelockMinDelayChange | null {
      return changetype<TimelockMinDelayChange | null>(
        store.get("TimelockMinDelayChange", id)
      );
    }
  
    get id(): string {
      let value = this.get("id");
      return value!.toString();
    }
  
    set id(value: string) {
      this.set("id", Value.fromString(value));
    }
  
    get emitter(): Bytes {
      let value = this.get("emitter");
      return value!.toBytes();
    }
  
    set emitter(value: Bytes) {
      this.set("emitter", Value.fromBytes(value));
    }
  
    get transaction(): string {
      let value = this.get("transaction");
      return value!.toString();
    }
  
    set transaction(value: string) {
      this.set("transaction", Value.fromString(value));
    }
  
    get timestamp(): BigInt {
      let value = this.get("timestamp");
      return value!.toBigInt();
    }
  
    set timestamp(value: BigInt) {
      this.set("timestamp", Value.fromBigInt(value));
    }
  
    get contract(): Bytes {
      let value = this.get("contract");
      return value!.toBytes();
    }
  
    set contract(value: Bytes) {
      this.set("contract", Value.fromBytes(value));
    }
  
    get delay(): BigInt {
      let value = this.get("delay");
      return value!.toBigInt();
    }
  
    set delay(value: BigInt) {
      this.set("delay", Value.fromBigInt(value));
    }
  }
  
  export class VotingContract extends Entity {
    constructor(id: Bytes) {
      super();
      this.set("id", Value.fromBytes(id));
    }
  
    save(): void {
      let id = this.get("id");
      assert(id != null, "Cannot save VotingContract entity without an ID");
      if (id) {
        assert(
          id.kind == ValueKind.BYTES,
          `Entities of type VotingContract must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
        );
        store.set("VotingContract", id.toBytes().toHexString(), this);
      }
    }
  
    static load(id: Bytes): VotingContract | null {
      return changetype<VotingContract | null>(
        store.get("VotingContract", id.toHexString())
      );
    }
  
    get id(): Bytes {
      let value = this.get("id");
      return value!.toBytes();
    }
  
    set id(value: Bytes) {
      this.set("id", Value.fromBytes(value));
    }
  
    get asAccount(): Bytes {
      let value = this.get("asAccount");
      return value!.toBytes();
    }
  
    set asAccount(value: Bytes) {
      this.set("asAccount", Value.fromBytes(value));
    }
  
    get totalWeight(): string {
      let value = this.get("totalWeight");
      return value!.toString();
    }
  
    set totalWeight(value: string) {
      this.set("totalWeight", Value.fromString(value));
    }
  
    get weight(): Array<string> {
      let value = this.get("weight");
      return value!.toStringArray();
    }
  
    set weight(value: Array<string>) {
      this.set("weight", Value.fromStringArray(value));
    }
  
    get delegation(): Array<string> {
      let value = this.get("delegation");
      return value!.toStringArray();
    }
  
    set delegation(value: Array<string>) {
      this.set("delegation", Value.fromStringArray(value));
    }
  
    get delegateChangedEvent(): Array<string> {
      let value = this.get("delegateChangedEvent");
      return value!.toStringArray();
    }
  
    set delegateChangedEvent(value: Array<string>) {
      this.set("delegateChangedEvent", Value.fromStringArray(value));
    }
  
    get delegateVotesChangedEvent(): Array<string> {
      let value = this.get("delegateVotesChangedEvent");
      return value!.toStringArray();
    }
  
    set delegateVotesChangedEvent(value: Array<string>) {
      this.set("delegateVotesChangedEvent", Value.fromStringArray(value));
    }
  }
  
  export class VoteDelegation extends Entity {
    constructor(id: string) {
      super();
      this.set("id", Value.fromString(id));
    }
  
    save(): void {
      let id = this.get("id");
      assert(id != null, "Cannot save VoteDelegation entity without an ID");
      if (id) {
        assert(
          id.kind == ValueKind.STRING,
          `Entities of type VoteDelegation must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
        );
        store.set("VoteDelegation", id.toString(), this);
      }
    }
  
    static load(id: string): VoteDelegation | null {
      return changetype<VoteDelegation | null>(store.get("VoteDelegation", id));
    }
  
    get id(): string {
      let value = this.get("id");
      return value!.toString();
    }
  
    set id(value: string) {
      this.set("id", Value.fromString(value));
    }
  
    get contract(): Bytes {
      let value = this.get("contract");
      return value!.toBytes();
    }
  
    set contract(value: Bytes) {
      this.set("contract", Value.fromBytes(value));
    }
  
    get delegator(): Bytes {
      let value = this.get("delegator");
      return value!.toBytes();
    }
  
    set delegator(value: Bytes) {
      this.set("delegator", Value.fromBytes(value));
    }
  
    get delegatee(): Bytes {
      let value = this.get("delegatee");
      return value!.toBytes();
    }
  
    set delegatee(value: Bytes) {
      this.set("delegatee", Value.fromBytes(value));
    }
  
    get delegateChangedEvent(): Array<string> {
      let value = this.get("delegateChangedEvent");
      return value!.toStringArray();
    }
  
    set delegateChangedEvent(value: Array<string>) {
      this.set("delegateChangedEvent", Value.fromStringArray(value));
    }
  }
  
  export class VoteWeight extends Entity {
    constructor(id: string) {
      super();
      this.set("id", Value.fromString(id));
    }
  
    save(): void {
      let id = this.get("id");
      assert(id != null, "Cannot save VoteWeight entity without an ID");
      if (id) {
        assert(
          id.kind == ValueKind.STRING,
          `Entities of type VoteWeight must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
        );
        store.set("VoteWeight", id.toString(), this);
      }
    }
  
    static load(id: string): VoteWeight | null {
      return changetype<VoteWeight | null>(store.get("VoteWeight", id));
    }
  
    get id(): string {
      let value = this.get("id");
      return value!.toString();
    }
  
    set id(value: string) {
      this.set("id", Value.fromString(value));
    }
  
    get contract(): Bytes {
      let value = this.get("contract");
      return value!.toBytes();
    }
  
    set contract(value: Bytes) {
      this.set("contract", Value.fromBytes(value));
    }
  
    get account(): Bytes | null {
      let value = this.get("account");
      if (!value || value.kind == ValueKind.NULL) {
        return null;
      } else {
        return value.toBytes();
      }
    }
  
    set account(value: Bytes | null) {
      if (!value) {
        this.unset("account");
      } else {
        this.set("account", Value.fromBytes(<Bytes>value));
      }
    }
  
    get value(): BigInt {
      let value = this.get("value");
      return value!.toBigInt();
    }
  
    set value(value: BigInt) {
      this.set("value", Value.fromBigInt(value));
    }
  
    get delegateVotesChangedEvent(): Array<string> {
      let value = this.get("delegateVotesChangedEvent");
      return value!.toStringArray();
    }
  
    set delegateVotesChangedEvent(value: Array<string>) {
      this.set("delegateVotesChangedEvent", Value.fromStringArray(value));
    }
  }
  
  export class DelegateChanged extends Entity {
    constructor(id: string) {
      super();
      this.set("id", Value.fromString(id));
    }
  
    save(): void {
      let id = this.get("id");
      assert(id != null, "Cannot save DelegateChanged entity without an ID");
      if (id) {
        assert(
          id.kind == ValueKind.STRING,
          `Entities of type DelegateChanged must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
        );
        store.set("DelegateChanged", id.toString(), this);
      }
    }
  
    static load(id: string): DelegateChanged | null {
      return changetype<DelegateChanged | null>(store.get("DelegateChanged", id));
    }
  
    get id(): string {
      let value = this.get("id");
      return value!.toString();
    }
  
    set id(value: string) {
      this.set("id", Value.fromString(value));
    }
  
    get emitter(): Bytes {
      let value = this.get("emitter");
      return value!.toBytes();
    }
  
    set emitter(value: Bytes) {
      this.set("emitter", Value.fromBytes(value));
    }
  
    get transaction(): string {
      let value = this.get("transaction");
      return value!.toString();
    }
  
    set transaction(value: string) {
      this.set("transaction", Value.fromString(value));
    }
  
    get timestamp(): BigInt {
      let value = this.get("timestamp");
      return value!.toBigInt();
    }
  
    set timestamp(value: BigInt) {
      this.set("timestamp", Value.fromBigInt(value));
    }
  
    get delegation(): string | null {
      let value = this.get("delegation");
      if (!value || value.kind == ValueKind.NULL) {
        return null;
      } else {
        return value.toString();
      }
    }
  
    set delegation(value: string | null) {
      if (!value) {
        this.unset("delegation");
      } else {
        this.set("delegation", Value.fromString(<string>value));
      }
    }
  
    get contract(): Bytes {
      let value = this.get("contract");
      return value!.toBytes();
    }
  
    set contract(value: Bytes) {
      this.set("contract", Value.fromBytes(value));
    }
  
    get delegator(): Bytes {
      let value = this.get("delegator");
      return value!.toBytes();
    }
  
    set delegator(value: Bytes) {
      this.set("delegator", Value.fromBytes(value));
    }
  
    get fromDelegate(): Bytes {
      let value = this.get("fromDelegate");
      return value!.toBytes();
    }
  
    set fromDelegate(value: Bytes) {
      this.set("fromDelegate", Value.fromBytes(value));
    }
  
    get toDelegate(): Bytes {
      let value = this.get("toDelegate");
      return value!.toBytes();
    }
  
    set toDelegate(value: Bytes) {
      this.set("toDelegate", Value.fromBytes(value));
    }
  }
  
  export class DelegateVotesChanged extends Entity {
    constructor(id: string) {
      super();
      this.set("id", Value.fromString(id));
    }
  
    save(): void {
      let id = this.get("id");
      assert(id != null, "Cannot save DelegateVotesChanged entity without an ID");
      if (id) {
        assert(
          id.kind == ValueKind.STRING,
          `Entities of type DelegateVotesChanged must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
        );
        store.set("DelegateVotesChanged", id.toString(), this);
      }
    }
  
    static load(id: string): DelegateVotesChanged | null {
      return changetype<DelegateVotesChanged | null>(
        store.get("DelegateVotesChanged", id)
      );
    }
  
    get id(): string {
      let value = this.get("id");
      return value!.toString();
    }
  
    set id(value: string) {
      this.set("id", Value.fromString(value));
    }
  
    get emitter(): Bytes {
      let value = this.get("emitter");
      return value!.toBytes();
    }
  
    set emitter(value: Bytes) {
      this.set("emitter", Value.fromBytes(value));
    }
  
    get transaction(): string {
      let value = this.get("transaction");
      return value!.toString();
    }
  
    set transaction(value: string) {
      this.set("transaction", Value.fromString(value));
    }
  
    get timestamp(): BigInt {
      let value = this.get("timestamp");
      return value!.toBigInt();
    }
  
    set timestamp(value: BigInt) {
      this.set("timestamp", Value.fromBigInt(value));
    }
  
    get voteWeight(): string | null {
      let value = this.get("voteWeight");
      if (!value || value.kind == ValueKind.NULL) {
        return null;
      } else {
        return value.toString();
      }
    }
  
    set voteWeight(value: string | null) {
      if (!value) {
        this.unset("voteWeight");
      } else {
        this.set("voteWeight", Value.fromString(<string>value));
      }
    }
  
    get contract(): Bytes {
      let value = this.get("contract");
      return value!.toBytes();
    }
  
    set contract(value: Bytes) {
      this.set("contract", Value.fromBytes(value));
    }
  
    get delegate(): Bytes {
      let value = this.get("delegate");
      return value!.toBytes();
    }
  
    set delegate(value: Bytes) {
      this.set("delegate", Value.fromBytes(value));
    }
  
    get oldValue(): BigInt {
      let value = this.get("oldValue");
      return value!.toBigInt();
    }
  
    set oldValue(value: BigInt) {
      this.set("oldValue", Value.fromBigInt(value));
    }
  
    get newValue(): BigInt {
      let value = this.get("newValue");
      return value!.toBigInt();
    }
  
    set newValue(value: BigInt) {
      this.set("newValue", Value.fromBigInt(value));
    }
  }
  
  export class Transaction extends Entity {
    constructor(id: string) {
      super();
      this.set("id", Value.fromString(id));
    }
  
    save(): void {
      let id = this.get("id");
      assert(id != null, "Cannot save Transaction entity without an ID");
      if (id) {
        assert(
          id.kind == ValueKind.STRING,
          `Entities of type Transaction must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
        );
        store.set("Transaction", id.toString(), this);
      }
    }
  
    static load(id: string): Transaction | null {
      return changetype<Transaction | null>(store.get("Transaction", id));
    }
  
    get id(): string {
      let value = this.get("id");
      return value!.toString();
    }
  
    set id(value: string) {
      this.set("id", Value.fromString(value));
    }
  
    get timestamp(): BigInt {
      let value = this.get("timestamp");
      return value!.toBigInt();
    }
  
    set timestamp(value: BigInt) {
      this.set("timestamp", Value.fromBigInt(value));
    }
  
    get blockNumber(): BigInt {
      let value = this.get("blockNumber");
      return value!.toBigInt();
    }
  
    set blockNumber(value: BigInt) {
      this.set("blockNumber", Value.fromBigInt(value));
    }
  
    get events(): Array<string> {
      let value = this.get("events");
      return value!.toStringArray();
    }
  
    set events(value: Array<string>) {
      this.set("events", Value.fromStringArray(value));
    }
  }
  